--TB3D 1.1.0.0.1.0 chgd abort service, added obj checks to release npc, added protection at unregister_npc, debug, print,
-- original unreg, db, get_obj_level, exclusives, show_smart_packets, promz/pred excepts, preserve_exclusives, debug
function my_ver() return "1.1.0.0.1.0" end

--[[------------------------------------------------------------------------------------------------------------------
Smart Terrain (machinery, organized all the stalkers and monsters at some stage)
Chugai Alexander
called first time after game spawns at first respawn
--------------------------------------------------------------------------------------------------------------------]]
local string_sub = string.sub
local string_gsub = string.gsub
local string_find = string.find
local math_random = math.random
local force_obinder = TB3D_Modders.use_smart_obinder				--110010, calls into game binder (alife)
if force_binder == nil then force_binder = true end
local check_period

if not editor() then
  check_period = game.CTime()
  check_period:setHMSms( 0, 0, 0, 50000 )
  CTime_0 = game.CTime()
end

local monster_classes
local disagreed, agreed, agreed_exclusive = 0, 1, 2
local smart_section = "smart_terrains"
--local smart_terrains = {}									--109976 moved to db
--local smart_terrains_by_name = {}

--exclusives = {}

--[[ a list of all server objects smarts, which are registered in the simulator
Format:
  smart_terrains = {
    level_name = { id=obj, id=obj, ... },
    level_name = { id=obj, id=obj, ... },
    ...
  }
]]

----------------------------------------------------------------------------------------------------------------------
-- Various useful functions
----------------------------------------------------------------------------------------------------------------------
-------------- Reading Aids ini (custom data) -------------------
-- TODO remove them
function r_str( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_string( section, line )
  else
    return default
  end
end

function r_num( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_float( section, line )
  else
    return default
  end
end

function r_2nums( spawn_ini, section, line, def1, def2 )
  if spawn_ini:line_exist( section, line ) then
    -- if the default-s is greater than the values ??in the ini, then the score, missing the last value from the ini
    local t = parse_nums( spawn_ini:r_string( section, line ) )
    local n = table.getn( t )
    if n == 0 then
      return def1, def2
    elseif n == 1 then
      return t[1], def2
    else
      return t[1], t[2]
    end
  else
    return def1, def2
  end
end

----------------------------------------------------------------------------------------------------------------------
-- Class "se_smart_terrain". Provides support for smart terrain offline.
-- Inherited from a script zone.
----------------------------------------------------------------------------------------------------------------------
class "se_smart_terrain" ( cse_alife_smart_zone )

function se_smart_terrain:__init( section ) super( section )
  self.initialized = false
  self.registred = false
end

function se_smart_terrain:detect_probability()
  return 0
end

function se_smart_terrain:print()
	if self.npc_info then
		for id, v in pairs( self.npc_info ) do
			TB3D_Services.packet_alert("SMT: id["..utils.to_str(id).."] name["..utils.to_str(v.name).."] class["..utils.to_str(v.class_id).."]") --causes CTD    se_obj["..utils.to_str(v.se_obj).."]")
			TB3D_Services.packet_alert("sect["..utils.to_str(v.section_name).."] story id["..utils.to_str(v.story_id).."] comm["..utils.to_str(v.community).."] rank["..utils.to_str(v.rank).."]")
			TB3D_Services.packet_alert("profile["..utils.to_str(v.profile_name).."] group["..utils.to_str(v.group).."] squad["..utils.to_str(v.squad).."] team["..utils.to_str(v.team).."]")
			TB3D_Services.packet_alert("dur end["..utils.to_str(v.duration_end).."] idle end["..utils.to_str(v.idle_end).."] working["..utils.to_str(v.gulag_working).."]")
		end
	else
		TB3D_Services.packet_alert("SMT: no npc info exists!!!!")
	end
end

-- preservation
function se_smart_terrain:STATE_Write( packet )
  if force_obinder then cse_alife_smart_zone.STATE_Write( self, packet ) end		--110010
  utils.w_CTime( packet, self.duration_end )
  utils.w_CTime( packet, self.idle_end )
  if self.gulag_working then
    packet:w_bool( true )
    self.gulag:save_common( packet )
    local n = 0
    for id, v in pairs( self.npc_info ) do
      n = n + 1
    end
    packet:w_u8( n )
    for id, v in pairs( self.npc_info ) do
      packet:w_u16  ( id )
      packet:w_u8   ( v.o_group )
      packet:w_u8   ( v.o_squad )
      packet:w_bool ( v.exclusive )
      utils.w_CTime ( packet, v.stay_end )
      self.gulag:save_obj( packet, id )
    end
    packet:w_bool ( self.population_locked )
  else
    packet:w_bool( false )
  end
	if TB3D_Modders.show_smart_packets or (TB3D_Modders.use_smt_message and self:name() == TB3D_Modders.npc_to_log) then --string_find(self:name(), TB3D_Modders.npc_to_log)) then
		TB3D_Services.packet_alert("SMT write: npc info["..self:name().."]")
		self:print()
		TB3D_Services.info_alert("SMT write: complete["..self:name().."]")
	end
end

-- recovery
function se_smart_terrain:STATE_Read( packet, size )
  if force_obinder then cse_alife_smart_zone.STATE_Read( self, packet, size ) end			--110010
--  self:print()
  self:read_params()
  -- under LevelEditor not try to read anything from the package
  if editor() then return end
  self.duration_end = utils.r_CTime( packet )
  self.idle_end     = utils.r_CTime( packet )
  self.gulag_working = packet:r_bool()
  -- if you have a working gulag
  if self.gulag_working then
    self.check_time = CTime_0
    self.gulag:load_common( packet )
    local n = packet:r_u8()
    local o_id, o
    for i = 1, n do
      o_id = packet:r_u16()
      self.npc_info[o_id] = {}
      o = self.npc_info[o_id]
      o.o_group   = packet:r_u8()
      o.o_squad   = packet:r_u8()
      o.exclusive = packet:r_bool()
      o.stay_end  = utils.r_CTime( packet )
      self.gulag:load_obj( packet, o_id )
    end
    self.population_locked = packet:r_bool()
  end
	if TB3D_Modders.show_smart_packets or (TB3D_Modders.use_smt_message and self:name() == TB3D_Modders.npc_to_log) then --string_find(self:name(), TB3D_Modders.npc_to_log)) then
		TB3D_Services.packet_alert("SMT read: npc info["..self:name().."]")
		self:print()
		TB3D_Services.info_alert("SMT read: complete["..self:name().."]")
	end
end

-- initiate work smart terrain.
-- after this function is fully functional smart.
-- called out of all places, which may lead to other sites:
--   se_smart_terrain:enabled()
--   se_smart_terrain:update()
--   xr_gulag.setup_gulag_and_logic_on_spawn()
--   xr_gulag.get_npc_gulag()
--   xr_gulag.get_gulag_by_name()
--   xr_gulag.get_gulag_by_sid()
function se_smart_terrain:initialize_if_needed()
  if not self.initialized then
    self:get_se_objs()
    self:preserve_exclusives()
    self.initialized = true
  end
end

-- reserve space for exclusive characters
function se_smart_terrain:preserve_exclusives()
	local e = db.exclusives[self:name()]
	if e then
		self.exclusives = e
		self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - e
		if self.gulag.capacity_non_exclusive < 0 then											-- Thought does not happen? Even as it is !!!
			if TB3D_Modders.pop_spawn_message then
				TB3D_Services.info_alert("SMT ERROR: preserve exclusives["..self:name().."] exc["..e.."] nexc["..utils.to_str(self.gulag.capacity_non_exclusive).."]")
			end
			self.gulag.capacity_non_exclusive = 0
		end
		db.remove_exclusives(self:name())		--109976
		--exclusives[self:name()] = nil
	else
		self.exclusives = 0
		self.gulag.capacity_non_exclusive = 1		--109995
	end
	--if self.exclusives == 0 and self.gulag.capacity_non_exclusive == 0 then self.gulag.capacity_non_exclusive = 1 end			--109955
	--TB3D_Services.info_alert("SMT: preserve exclusives["..self:name().."] exc["..utils.to_str(self.exclusives).."] nexc["..utils.to_str(self.gulag.capacity_non_exclusive).."]")
end

-- a server-side objects characters
function se_smart_terrain:get_se_objs()
  local sim = alife()
  local obj
  for id, v in pairs( self.npc_info ) do
    obj = sim:object( id )
    if obj == nil then	--!!!!TB3D after blowout save ctd
		if TB3D_Modders.pop_spawn_message then
			TB3D_Services.packet_alert("Smart Terrain: get se objs npc["..utils.to_str(self:name()).."] unregistering se_obj id["..utils.to_str(self.id).."]")
		end
		self:unregister_npc_id( id )
	else
		self:fill_npc_info( obj, v )
    end
  end
end

-- complete information about the character
-- Monsters have no method profile_name()
-- TODO transfer in predicates npc_info, and object
function se_smart_terrain:fill_npc_info( obj, npc_info )
  if not npc_info then
    npc_info = {}
  end
  npc_info.se_obj       = obj
  npc_info.class_id     = obj:clsid()
  npc_info.section_name = get_section(obj)
  npc_info.name         = obj:name()
  npc_info.story_id     = obj.m_story_id
  npc_info.community    = self:get_obj_community( obj )
	if obj.profile_name then
		npc_info.profile_name = obj:profile_name()	--!!!!TB3D
		if npc_info.profile_name then
			npc_info.is_sniper = string_find( npc_info.profile_name, "sniper" ) ~= nil
		end
	end
	npc_info.is_sniper_name = string_find( npc_info.name, "sniper" ) ~= nil
	if obj.rank then
		npc_info.rank         = obj:rank()
	else
		npc_info.rank         = nil
	end
	if obj.g_group then
		npc_info.group        = obj:g_group()
	else
		npc_info.group        = nil
	end
	if obj.g_squad then
		npc_info.squad        = obj:g_squad()
	else
		npc_info.squad        = nil
	end
	if obj.g_team then
		npc_info.team         = obj:g_team()
	else
		npc_info.team         = nil
	end
  local t               = obj.smart_terrain_conditions
  if t then
    t = t[self:name()]
  end
  npc_info.cond = t
	if (TB3D_Modders.use_setup_message and string_find(npc_info.name, TB3D_Modders.npc_to_log))
	  or (TB3D_Modders.use_smt_message and string_find(self:name(), TB3D_Modders.smt_to_log)) then
		TB3D_Services.packet_alert("smt: fill info name["..npc_info.name.."] sect["..npc_info.section_name.."] smt["..self:name().."]")
		TB3D_Services.packet_alert("smt: fill info sid["..utils.to_str(npc_info.story_id).."] comm["..utils.to_str(npc_info.community).."]")
		TB3D_Services.packet_alert("smt: fill info sniper["..utils.to_str(npc_info.is_sniper).."] by name["..utils.to_str(npc_info.is_sniper_name).."]")
		TB3D_Services.packet_alert("smt: fill info rank["..utils.to_str(npc_info.rank).."] group["..utils.to_str(npc_info.group).."] squad["..utils.to_str(npc_info.squad).."] team["..utils.to_str(npc_info.team).."]")
		TB3D_Services.packet_alert("smt: fill info cond["..utils.to_str(npc_info.cond).."]")
	end
  return npc_info
end

-- returns:
-- and) If a stalker: Stalker group, and true
-- b) if the monster: the monster type, and false
function se_smart_terrain:get_obj_community( obj )
  local cls = obj:clsid()
  if cls then
	  if cls == clsid.script_stalker then
		return obj:community(), true
	  else
		return monster_classes[cls], false
	  end
  end
  return nil, false		--TB3D !!!!   109928
end

-- initialization.
-- reading custom data.
function se_smart_terrain:read_params()
  local ini  = self:spawn_ini()
  local sect = "smart_terrain"
  if not ini:section_exist( sect ) then
    sect = "gulag1"
    if not ini:section_exist( sect ) then
		--if TB3D_Modders.use_smh1_message == true then
			TB3D_Services.info_alert("Smart terrain["..self:name().."] no configuration!")
		--end
		self.disabled = true
		return
    end
  end
  if not ini:line_exist( sect, "type" ) then
	--if TB3D_Modders.use_smh1_message == true then
		TB3D_Services.info_alert("Smart terrain["..self:name().."] type is not specified")
	--end
  end
  local gp       = {}
  self.npc_info  = {}          -- group and squad for each npc
  self.gparams   = gp          -- settings gulag
  gp.type        = ini:r_string( sect, "type" )
  gp.preset_name = r_str ( ini, sect, "preset" )
  gp.capacity    = r_num ( ini, sect, "capacity", 100 ) -- capacity. but the real capacity = min (eta_emkost, capacity gulag)
  gp.squad       = r_num ( ini, sect, "squad" )
  gp.idle_min,     gp.idle_max      = r_2nums( ini, sect, "idle",       0,     0 )
  gp.duration_min, gp.duration_max  = r_2nums( ini, sect, "duration",   10000, 10001 )
  gp.stay_min,     gp.stay_max      = smart_terrain_params.get_stay_time_interval( r_str( ini, sect, "stay", "default" ) )
  gp.respawn     = r_str ( ini, sect, "respawn" )
	--local cond_str = smart_terrain_params.check_respawn(self:name())					--TB3D check for bad spawns, not affect garbage sid bandits
	--if cond_str == nil then
		cond_str = r_str(ini, sect, "cond")
	--end
	if cond_str == nil then cond_str = "100" end
	gp.cond = xr_logic.parse_condlist( nil, sect, "cond", cond_str)
	gp.groups = r_str( ini, sect, "groups" )
	if gp.groups then gp.groups = parse_nums(gp.groups) end
  self.accepted_communities = nil
  local t = r_str( ini, sect, "communities" )
  if t then
    t = parse_names( t )
    self.accepted_communities = {}
    for i, v in ipairs( t ) do
      self.accepted_communities[v] = true
    end
  end
  local ltx = system_ini()
  self.rank_inc_min = ltx:r_string( "smart_terrain_rank_change", "min" )
  self.rank_inc_max = ltx:r_string( "smart_terrain_rank_change", "max" )
  self.population_locked = false
  self.gulag = xr_gulag.gulag( self, self.gparams.type, self.gparams.squad, self.gparams.groups, self.npc_info, self.gparams.capacity )
  self.gulag_working = false
	if TB3D_Modders.use_smt_message or TB3D_Modders.use_setup_message and string_find(self:name(), TB3D_Modders.npc_to_log) then
		TB3D_Services.packet_alert("Smart terrain:["..self:name().."] preset name["..utils.to_str(gp.preset_name).."] type["..utils.to_str(gp.type).."]")
		--TB3D_Services.packet_alert("groups:")
		--if gp.groups then show_tables(gp.groups, nil, "smart terrain") end
		if gp.groups then
			for i, v in ipairs(gp.groups) do
			  TB3D_Services.packet_alert("Smart terrain:["..self:name().."] group["..utils.to_str(v).."]")
			end
		end
		if self.accepted_communities then
			for i, v in ipairs(self.accepted_communities) do
			  TB3D_Services.packet_alert("Smart terrain:["..self:name().."] accepted community["..utils.to_str(v).."]")
			end
		end
		TB3D_Services.packet_alert("Smart terrain:["..self:name().."] respawn["..utils.to_str(gp.respawn).."] conditions["..utils.to_str(cond_str).."]")
		TB3D_Services.packet_alert("Smart terrain:["..self:name().."] stay time min["..utils.to_str(gp.stay_min).."] max["..utils.to_str(gp.stay_max).."]")
		TB3D_Services.packet_alert("Smart terrain:["..self:name().."] capacity["..utils.to_str(gp.capacity).."] squad["..utils.to_str(gp.squad).."]")
		TB3D_Services.packet_alert("Smart terrain:["..self:name().."] duration min["..utils.to_str(gp.duration_min).."] max["..utils.to_str(gp.duration_max).."]")
		TB3D_Services.packet_alert("Smart terrain:["..self:name().."] idle min["..utils.to_str(gp.idle_min).."] max["..utils.to_str(gp.idle_max).."]")
		TB3D_Services.packet_alert("Smart terrain:["..self:name().."] rank change rate min["..utils.to_str(self.rank_inc_min).."] max["..utils.to_str(self.rank_inc_max).."]")
		TB3D_Services.packet_alert("Smart terrain:["..self:name().."] locked["..utils.to_str(self.population_locked).."] working["..utils.to_str(self.gulag_working).."]")
	end
end

-- correspond to a character preset.
-- If a preset is not present, it is always appropriate.
function se_smart_terrain:check_preset( npc_community, npc_rank, preset_name )
  local preset = smart_terrain_params.get_preset( preset_name )
  if not preset then
    return true
  else
    local t = preset[npc_community]
    if t and ( npc_rank >= t[1] and npc_rank <= t[2] ) then
      return true
    else
      return false
    end
  end
end

--[[ correspond to object Gulag?
1) if the object does not agree to go here, the smart terrain it does not take
2) if the object agrees to go anywhere, then check whether there is still room if it fits the Gulag,
   if it fits at least one job
3) if the object only agree to go into this smart, then take place even if no (it will supplant someone), to check if it fits the Gulag, if it fits at least one job
]]
local level_groups = {
    l01_escape = "group1",
    l02_garbage = "group1",
    l03_agroprom = "group1",
    l03u_agr_underground = "group1",
    l04_darkvalley = "group1",
    l04u_labx18 = "group1",
    l05_bar = "group1",
    l06_rostok = "group1",
    l07_military = "group1",
    l08_yantar = "group1",
    l08u_brainlab = "group1",
    l10_radar = "group1",
    l10u_bunker = "group1",
    l11_pripyat = "group1",
    l12_stancia = "group3",
    l12u_sarcofag = "group3",
    l12u_control_monolith = "group3",
    l12_stancia_2 = "group3",
	-----new-------------------
	atp_for_test22 = "group1",
	peshera = "group1",
	av_peshera = "group1",
	puzir = "group1",
	aver = "group1",
	limansk = "group1",
	hospital = "group1",
	generators = "group1",
	warlab = "group1",
	red_forest = "group1",
	lost_village = "group1",
	marsh = "group1",
	dead_city = "group1",
	zaton = "group1",
	jupiter = "group1",
	pripyat = "group1",
	jupiter_underground = "group1",
	labx8 = "group1",
	cs_agroprom_underground	 = "group5",
	predbannik = "group4",
	--garbage_old = "group1",   --not used
	yantar_old = "group4",
	swamp_old = "group4",
	hiding_road = "group4",
	k01_darkscape = "group4",
	dark_forest = "group4",
	level_f1 = "group5",							--level_f-1 = "group1",				--dash causes compiler error
	promzone = "group4",
	--deadcity = "group1",							--not used
	digger_stash = "group4",
	l01_krasivay = "group4",
	l02_dd = "group4",
	l03_rinok = "group4",
	l04_pogost = "group4",
	l05_vokzal = "group4",
	lab_x14 = "group5",
	l01_poligon = "group6"
	--collector22 = "group1"						--not used
}

function se_smart_terrain:smart_terrain_accepts_obj(obj, obj_agreement)
	local sname = self:name()			--smart terrain name
	if obj and obj.name then
		local oname = obj:name()		--npc name
		local is_report = false
		if TB3D_Modders.use_smh1_message == true or (TB3D_Modders.use_setup_message and string_find(oname, TB3D_Modders.npc_to_log))
		  or (TB3D_Modders.use_smt_message and sname == TB3D_Modders.smt_to_log) then is_report = true end
		if obj_agreement == disagreed then
			--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] = [disagreed]") end
			return false
		end
		if oname == "l01_stalker_0032" then return false end		--110010, this one freezes game, up to 37 seem ok
		--' if obj:name() == "esc_wolf" then
		--'   printf("before checking: pop = %s, cap = %s", tostring(self.gulag:get_non_exclusive_population()), tostring(self.gulag.capacity_non_exclusive))
		--' end
		if obj_agreement == agreed_exclusive or	(obj_agreement == agreed and self.gulag:get_non_exclusive_population() < self.gulag.capacity_non_exclusive) then
			--TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] can try fill smart?")
			local community, is_stalker = self:get_obj_community(obj)
			--' Check that smart and NPCs are in the same cluster levels (that did not go through BAR)
			local smart_level_group = self:get_level_name()
			local npc_level_group = TB3D_Services.get_obj_level(obj.m_game_vertex_id)
			--' if obj:name() == "esc_wolf" then
			--'    printf("smart=%s stalker=%s", tostring(smart_level_group), tostring(npc_level_group))
			--' end
			if smart_level_group == nil or npc_level_group == nil then
				--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] nil level["..utils.to_str(smart_level_group).."]["..utils.to_str(npc_level_group).."] !!!!") end
				return false
			end
			if smart_level_group == "" or npc_level_group == "" then
				--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] no group["..utils.to_str(smart_level_group).."]["..utils.to_str(npc_level_group).."] !!!!") end
				return false
			end
			if smart_level_group == "level_f-1" then smart_level_group = "level_f1" end			--f-1 causes compiler error
			if npc_level_group == "level_f-1" then npc_level_group = "level_f1" end
			local sgroup = level_groups[smart_level_group]
			local ngroup = level_groups[npc_level_group]
			if sgroup == nil or ngroup == nil then
				--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] nil group["..utils.to_str(sgroup).."]["..utils.to_str(ngroup).."] !!!!") end
				return false
			end
			if sgroup ~= ngroup then
				--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] wrong group["..utils.to_str(level_groups[sgroup]).."]["..utils.to_str(level_groups[ngroup]).."] !!!!") end
				return false
			end
			--' if obj:name() == "esc_wolf" then
			--'   printf( "comm=%s is_stalker=%s", community, tostring( is_stalker ) )
			--' end
			if self.accepted_communities and not self.accepted_communities[community] then
				--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] not accepted community["..utils.to_str(community).."]") end
				return false
			end
			--'   if obj:name() == "esc_wolf" then
			--'     printf( "community=%s rank=%d reputation=%d", community, obj:rank(), obj:reputation() )
			--'   end
			if not self:check_preset( community, obj:rank(), self.gparams.preset_name ) then
				--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] preset for["..oname.."] is not ok, not accepted") end
				return false
			end
			--'   if obj:name() == "esc_wolf" then
			--'     printf( "check_preset ok" )
			--'   end
			if not xr_gulag.checkNpc( community, is_stalker, self.gparams.type, obj:rank(), obj ) then
				--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] not accepted") end
				return false
			end
			--' if obj:name() == "esc_wolf" then
			--'   printf( "checkNpc ok" )
			--' end
			local hdr_smt = string_sub(sname, 1, 5)
			local hdr_obj = string_sub(oname, 1, 5)
			if hdr_smt == "promz" or hdr_smt == "pred_" then
				if hdr_smt ~= hdr_obj then
					--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] blocked!!!!") end
					return false
				end
			end
			local is_job = self.gulag:is_there_any_suitable_job( self:fill_npc_info( obj ), obj_agreement == agreed_exclusive )
			if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] job["..utils.to_str(is_job).."] = [agreed_exclusive]") end
			return is_job
		else
			--if is_report then TB3D_Services.packet_alert("smt: smart_terrain_accepts_obj smt["..sname.."] npc["..oname.."] no jobs") end
			return false
		end
	end
	TB3D_Services.abort_alert("smt: smart_terrain_accepts_obj smt["..sname.."] no object or object name!!!!")
	return false
end

--[[ correspond to the gulag object?
the object in the custom data prescribed conditions for some smart_terrains:
  <smart_terrain_name1> = <condlist1>
  <smart_terrain_name2> = <condlist2>
  ...
If for some smart_terrain condition is satisfied, it is the exclusive.
If an object has appeared at least one exclusive smart terrain, it will only agree to go into it.
If you do not add any exclusive, he agreed to go into any.
]]
-- TODO and if at the beginning of an exclusive, and then to anyone?
-- option: any=condlist
function se_smart_terrain:obj_accepts_smart_terrain( obj )
	local sname = self:name()
	if obj then
		local oname = obj:name()
		if (obj.smart_terrain_conditions) then
			--local any_exclusive = false
			local s
			local is_report = false
			if TB3D_Modders.use_smh1_message == true or (TB3D_Modders.use_setup_message and string_find(oname, TB3D_Modders.npc_to_log))
			  or (TB3D_Modders.use_smt_message and sname == TB3D_Modders.smt_to_log) then is_report = true end
			for name, condlist in pairs(obj.smart_terrain_conditions) do
				if name then
					if name == "none" then        
						--if is_report then TB3D_Services.packet_alert("smt: obj_accepts_smt["..sname.."] obj["..oname.."] name[none] = [disagreed]") end
						return disagreed
					end
					s = nil
					s = xr_logic.pick_section_from_condlist( db.actor, obj, condlist )
					if s ~= nil then
						if name == sname then
							if is_report then TB3D_Services.packet_alert("smt: obj_accepts_smt["..sname.."] obj["..oname.."] agreed_exclusive["..name.."] = [agreed exclusive]") end
							return agreed_exclusive
						end
					elseif name == sname then					--' If the current smart is exclusive and not available
						--if is_report then TB3D_Services.packet_alert("smt: obj_accepts_smt["..sname.."] obj["..oname.."] not available["..name.."] = [disagreed]") end
						return disagreed
					end
				end
			end			--not exclusive but might fit non-exclusives
			--' If an object is forbidden to move online and exclusive
			--' Smarts unavailable, do not let him anywhere. This eliminates
			--' the transfer of disabled before (or after) the specified event
			--' humans and mutants in other non-exclusive Smart.
			--[[	110008
			if (obj.can_switch_online) and obj:can_switch_online() == false then
				--if is_report then TB3D_Services.packet_alert("smt: obj_accepts_smt["..sname.."] obj["..oname.."] non exclusive cso[false] = [disagreed]") end
				return disagreed
			end
			--]]
			--' It is necessary to ensure that exclusive smart is available before blocking others
			--'   if any_exclusive then
			--'     if obj:name() == "gar_bandit_agr_10" then
			--'       printf("[%s] obj_accepts_smart_terrain[%s] = disagreed. excl=%s", self:name(), obj:name(), tostring(any_exclusive))
			--'     end
			--'     return disagreed
			--'   end
			local hdr_smt = string_sub(sname, 1, 5)
			local hdr_obj = string_sub(oname, 1, 5)
			if hdr_obj == "promz" or hdr_obj == "pred_" then
				--if not string_find(sname, oname) then
					if hdr_smt ~= hdr_obj then
						--if is_report then
							--TB3D_Services.packet_alert("smt: obj_accepts_smt["..sname.."] obj["..oname.."] non exclusive cso[true] = [disagreed]")
						--end
						return disagreed
					end
				--end
			end
			if is_report then TB3D_Services.packet_alert("smt: obj_accepts_smt["..sname.."] obj["..oname.."] non exclusive cso[true] = [agreed]") end
			return agreed
		end
		--' does not have smart terrain conditions but depends on a smart
		if sname == "mil_freedom" then
			if string_find(oname, "mil_freedom_respawn") then return agreed else return disagreed end
		elseif sname == "mil_fneutral" then
			if string_find(oname, "barier_respawn") then return agreed else return disagreed end
		end
		--' otherwise block them from using it
		--if is_report then TB3D_Services.packet_alert("smt: obj_accepts_smt["..sname.."] obj["..oname.."] no smart cond = [disagreed]") end
		return disagreed
	end
	if is_report then TB3D_Services.packet_alert("smt: obj_accepts_smt["..sname.."] obj[nil] no object = [disagreed] !!!!") end
	return disagreed
end

-- whether an object can be added to smart terrain?
-- simulator is invoked when the job search for the object / group.
-- if the object - a group that returns true only if all objects in the group return true
function se_smart_terrain:enabled(obj)
	if self and self.id and obj then
		local oname = obj:name()
		local sname = self:name()
		local is_report = false
		if TB3D_Modders.use_smh1_message == true or (TB3D_Modders.use_setup_message and string_find(oname, TB3D_Modders.npc_to_log))
		  or (TB3D_Modders.use_smt_message and sname == TB3D_Modders.smt_to_log) then is_report = true end
		if self.disabled then  -- DEBUG
			if is_report then TB3D_Services.packet_alert("smt: enabled smt["..sname.."] obj["..oname.."] is disabled") end
			return false
		end
		self:register_if_needed()
		self:initialize_if_needed()
		if self:is_gulag_available() then
			if not self.population_locked then
				local b = self:obj_accepts_smart_terrain( obj )
				if b > 0 then																		--agreed or agreed_exclusive
					local a = self:smart_terrain_accepts_obj( obj, b )
					--'   if obj:name() == "esc_wolf" then
					--'     if a == true then
					--'       printf("[smart_terrain %s] ENABLED obj=%s exclusive=%s", self:name(), obj:name(), tostring(b))
					--'     else
					--'       printf("[smart_terrain %s] DISABLED obj=%s  accept_obj = %s", self:name(), obj:name(), tostring(b))
					--'     end
					--'   end
					if is_report then TB3D_Services.packet_alert("smt: enabled smt["..sname.."] obj["..oname.."] gulag available and object excepted smt excepts["..utils.to_str(a).."]") end
					return a
				end
				if is_report then TB3D_Services.packet_alert("smt: enabled smt["..sname.."] obj["..oname.."] gulag available and object not excepted smt") end
				return false
			end
			if is_report then TB3D_Services.packet_alert("smt: enabled smt["..sname.."] obj["..oname.."] gulag available but population locked") end
			return false
		else
			--'   if obj:name() == "esc_wolf" then
			--'     printf("[smart_terrain %s] DISABLED not_enabled", self:name())
			--'   end
		end
		if is_report then TB3D_Services.packet_alert("smt: enabled smt["..sname.."] obj["..oname.."] not available") end
	end
	return false
end

-- returns the number of characters in smart.
-- called for all smarts who have returned from the true enabled
-- in order to choose the one in which the character will still.
-- Criteria:
--   1) if the object has already been in other smarts, the more free papers at the level of Smart, the better
--   2) otherwise closer - better
-- TODO Optimize
function se_smart_terrain:suitable(obj)
	--' if obj:name() == "esc_wolf" then
	--'   printf("[%s] suitable [%s]", self:name(), obj:name())
	--' end
	local v = 0
	if self:obj_accepts_smart_terrain(obj) == agreed_exclusive then
		v = 100000 --'So that all are inherently better than an exclusive
	end
	local s_level = self:get_level_name()
	local smarts = db.smart_terrains[s_level]			--109976
	if s_level ~= "" then
		for id, strn in pairs(smarts) do
			if strn.is_gulag_available and strn:is_gulag_available() then
				v = v + strn.gulag.capacity - strn.gulag:get_population()
			end
		end
	end
	--' if obj:name() == "esc_wolf" then
	--'   printf( "[smart_terrain %s] obj=%s suitable=%d was_in_smart_terrain=%s",
	--'           self:name(),
	--'           obj:name(),
	--'       v,
	--'           tostring(obj.was_in_smart_terrain) )
	--' end
	return v
end

-- add npc in smart terrain.
-- if no place or no suitable work available, then
-- push from the smart terrain with a suitable job object that hit him did not exclusively.
function se_smart_terrain:register_npc(obj)
	if self and obj then
		local npc_info = {
			-- old squad and group
			o_group = obj:g_group(),
			o_squad = obj:g_squad(),
			exclusive = self:obj_accepts_smart_terrain(obj) == agreed_exclusive,
			--move_offline = o:move_offline(),
			stay_end = game.CTime()
			}
		if npc_info then
			self:fill_npc_info(obj, npc_info)
			if self.gulag_working and
				--     ( self.gulag:get_population() == self.gulag.capacity or
				not self.gulag:is_there_any_suitable_job(npc_info, false) --)
				then
					--printf( "get_population=%d capacity=%d", self.gulag:get_population(), self.gulag.capacity )
					--printf( "is_there_any_suitable_job=%s", tostring(self.gulag:is_there_any_suitable_job(npc_info, false)) )
					if TB3D_Modders.show_tables then show_tables(self.npc_info, nil, "smart terr") end
					TB3D_Services.packet_alert("smt: reg npc ["..utils.to_str(self:name()).."] kick someone out for["..utils.to_str(obj:name()).."] !!!!")
					self:kick_someone_non_exclusive(npc_info)
			end
			self:update_obj_rank(obj)
			obj.was_in_smart_terrain = true
			self.npc_info[obj.id] = npc_info
			t = self.npc_info[obj.id].stay_end
			--  t:setHMSms( 0, 0, 0, math.random( self.gparams.stay_min * h2ms, self.gparams.stay_max * h2ms ) )
			t:setHMSms(math.random(self.gparams.stay_min, self.gparams.stay_max), 0, 0, 0)
			t:add(game.get_game_time())
			--  o:move_offline( false )
			if self and not self.gulag_working then
				--TB3D_Services.packet_alert("smt: register npc["..utils.to_str(obj:name()).."]["..utils.to_str(self:name()).."] not working")
				self:create_gulag()
			end
			self.gulag:addObject(obj.id)
			self.gulag:update()
			--TB3D_Services.packet_alert("smt: ["..utils.to_str(self:name()).."] added["..utils.to_str(obj:name()).."] to gulag type["..utils.to_str(self.gparams.type).."]")
		end
	else
		TB3D_Services.packet_alert("smt: register npc[self or obj is nil] !!!!!!!!!!!")
	end
end

function se_smart_terrain:unregister_npc( obj )
	if obj then
		if obj.id then
			if TB3D_Modders.use_smh3_message then TB3D_Services.info_alert("SMT: unregister["..utils.to_str(obj:name()).."]") end  -- from gulag["..utils.to_str(obj:smart_terrain_id()).."]") end
			local n = self.npc_info[obj.id]
			if obj.alive and not obj:alive() and obj.smart_terrain_conditions then
				local s
				for name, condlist in pairs(obj.smart_terrain_conditions) do
					s = nil
					s = xr_logic.pick_section_from_condlist( db.actor, obj, condlist )
					if s ~= nil then
						if name == self:name() then
							if self.exclusives > 0 then self.exclusives = self.exclusives - 1 end
							self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive + 1
						end
					end
				end
			end
			if TB3D_Modders.use_smh3_message then TB3D_Services.info_alert("SMT: removed["..utils.to_str(obj:name()).."]") end  -- from gulag["..utils.to_str(obj:smart_terrain_id()).."]") end
			self.gulag:removeObject( obj.id )
			if n then
				obj.squad = n.o_squad
				obj.group = n.o_group
			end
			self.npc_info[obj.id] = nil
			if obj.clear_smart_terrain then obj:clear_smart_terrain() end
		else
			TB3D_Services.packet_alert("smt: object id does not exist")
			if obj.clear_smart_terrain then obj:clear_smart_terrain() end
		end
	else
		TB3D_Services.packet_alert("smt: object does not exist")
	end
end

function se_smart_terrain:unregister_npc_id( id )
	if id then
		self.gulag:removeObject(id)
		self.npc_info[id] = nil
		if self.exclusives and self.exclusives > 0 then self.exclusives = self.exclusives - 1 end
		if self.gulag.capacity_non_exclusive then self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive + 1 end
	end
end

-- change the rank of a stalker during the registration in the smart
function se_smart_terrain:update_obj_rank( obj )
	if obj and db.actor then
		if obj.id == db.actor:id() then
			TB3D_Services.info_alert("smt: tried randomize the player rank!!!!")
		else
			local community, is_stalker = self:get_obj_community( obj )
			if is_stalker then
				local old_rank = obj:rank()
				obj:set_rank( old_rank + math.random( self.rank_inc_min, self.rank_inc_max ) )
			end
		end
	end
end

-- expelled from the first that fell smart terrain non-exclusive character,
-- which is the work that is appropriate to the new character.
-- TODO and if I pasture someone, and his work is not suitable for idle ?
function se_smart_terrain:kick_someone_non_exclusive( new_npc_info )
	if self.npc_info and new_npc_info then
		for obj_id, npc_info in pairs( self.npc_info ) do
			if npc_info and not npc_info.exclusive and self.gulag:obj1_job_suits_obj2( obj_id, new_npc_info ) then
				if TB3D_Modders.use_smh2_message then
					TB3D_Services.packet_alert("smt: kick non excl ["..utils.to_str(npc_info.se_obj:name()).."] unregistered !!!!")
				end
			  self:unregister_npc( npc_info.se_obj )
			  return
			end
		end
	end
	if TB3D_Modders.use_smh1_message then TB3D_Services.info_alert("Smart terrain: ["..utils.to_str(self:name()).."] can't add npc, all are exclusive or there are no suitable jobs") end
end

-- issue a task object.
function se_smart_terrain:task( obj )
	if self and self.id and obj then
	  local path_name = self.gulag:get_obj_job_path_name( obj.id )
	  if not path_name then
		--if TB3D_Modders.use_smh1_message then
			--TB3D_Services.info_alert("SMT: task, path not found! CLEARING["..obj:name().."]")
		--end
		self:unregister_npc(obj) --'Gag against departure.
		return CALifeSmartTerrainTask("simulation_default_path")
	  end
--' printf("SEETING TASK PATH %s = %s", obj:name(), path_name)
  --' Trying proapdeytit Tips bloke on the map
--' if sim_statistic.show_stalker_spot == true and obj:alive() then
--'   local community, rank = sim_statistic.getNpcType(obj)
--'   local spot = "alife_presentation_monstr"
--'   if IAmAStalker[obj:clsid()] then
--'     spot = "alife_presentation_"..community
--'   end
--'   local str = obj:name().." "..self:name().."\\n"..path_name
--'   level.map_change_spot_hint(obj.id, spot, str)   
--' end
		return CALifeSmartTerrainTask( path_name )
	end
end

-- whether this gulag be created at the moment?
function se_smart_terrain:is_gulag_available()
  if self.gparams.cond then
    local bb = xr_logic.pick_section_from_condlist( db.actor, self, self.gparams.cond ) ~= nil
--'   self:show_smart_debug_spot(bb)
--'   if self:name() == "gar_bandit_agr" then
--'     printf("[smartterrain %s] is_gulag_available = %s", self:name(), tostring(bb))
--'   end
	--TB3D_Services.packet_alert("smt: is_gulag_available["..self:name().."] ["..utils.to_str(bb).."]")
    return bb
  else
--'   self:show_smart_debug_spot(true)
--'   if self:name() == "gar_bandit_agr" then
--'     printf("[smartterrain %s] is_gulag_available = %s extra", self:name(), tostring(true))
--'   end
    return true
  end
end

--[[
function se_smart_terrain:show_smart_debug_spot(avail)
  if TB3D_Modders.use_sim_statistics and sim_statistic.show_smart_spot == true then
    --' Show the mark
    local str = self:name().." ("..tostring(self.gulag.state)..")\\n".."pop = "..tostring(self.gulag:get_population()).."("..tostring(self.gulag.capacity_non_exclusive)..":"..tostring(self.gulag.capacity)..") comed = "..tostring(self.gulag:get_population_comed())
    if self.debug_avail ~= avail then
      if self.debug_avail == true then
        level.map_remove_object_spot(self.id, "alife_presentation_smart_on")
      elseif self.debug_avail == false then
        level.map_remove_object_spot(self.id, "alife_presentation_smart_off")
      end
      if avail == true then
		if level.map_has_object_spot(self.id, "alife_presentation_smart_on") == 0 then
			level.map_add_object_spot(self.id, "alife_presentation_smart_on", str)
		end
      else
		if level.map_has_object_spot(self.id, "alife_presentation_smart_on") == 0 then
			level.map_add_object_spot(self.id, "alife_presentation_smart_on", str)
		end
	  end
      self.debug_avail = avail
    else
      if avail == true then
        level.map_change_spot_hint(self.id, "alife_presentation_smart_on", str)
      else
        level.map_change_spot_hint(self.id, "alife_presentation_smart_off", str)
      end
    end
     self.spot_showed = true
  else
    --' Remove mark
    if self.spot_showed == nil then
      return
    end
    self.spot_showed = nil
    if self.debug_avail == true then
      level.map_remove_object_spot(self.id, "alife_presentation_smart_on")
    else
      level.map_remove_object_spot(self.id, "alife_presentation_smart_off")
    end   
  end
end
]]--
-- installation / acceptance of characters to unlock
function se_smart_terrain:lock_population( need_lock )
  self.population_locked = need_lock
end

-- in the gulag is first received character, and he begins to work
function se_smart_terrain:create_gulag()
	if self and self.gulag then
		--TB3D_Services.packet_alert("smt: create_gulag["..self:name().."]")
	  self.duration_end = game.CTime()
	--  self.duration_end:setHMSms( 0, 0, 0, math.random( self.gparams.duration_min * h2ms, self.gparams.duration_max * h2ms ) )
	  self.duration_end:setHMSms( math.random( self.gparams.duration_min, self.gparams.duration_max ), 0, 0, 0 )
	  self.duration_end:add( game.get_game_time() )
	  self.check_time = CTime_0
	  self.gulag:initialize()
	  self.gulag_working = true
		--TB3D_Services.packet_alert("smt: create_gulag["..self:name().."] done")
	else
		TB3D_Services.packet_alert("smt: create_gulag[self is nil] !!!!!!!!!!!")
	end
end

-- all free, kill the gulag,
-- create a new non-working gulag, to reserve it for exclusive places
function se_smart_terrain:remove_gulag( disable )
	self.disabled = disable	-- DEBUG
	if not self.gulag_working then return end
	-- release of all the characters
	for id, npc_info in pairs( self.npc_info ) do
		--TB3D_Services.packet_alert("smt: remove gulag id["..utils.to_str(npc_info.se_obj).."] unregistered")
		if npc_info.se_obj then self:unregister_npc( npc_info.se_obj ) end
	end
	if self.gparams.idle_max > 0 then
		self.idle_end = game.CTime()
		--self.idle_end:setHMSms( 0, 0, 0, math.random( self.gparams.idle_min * h2ms, self.gparams.idle_max * h2ms ) )
		self.idle_end:setHMSms( math.random( self.gparams.idle_min, self.gparams.idle_max ), 0, 0, 0 )
		self.idle_end:add( game.get_game_time() )
	else
		self.idle_end = nil
	end
	self.gulag = xr_gulag.gulag( self, self.gparams.type, self.gparams.squad, self.gparams.groups, self.npc_info, self.gparams.capacity )
	self.gulag:load_jobs()
	self.gulag_working = false
	self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - self.exclusives
	if self.gulag.capacity_non_exclusive < 0 then
		--TB3D_Services.packet_alert("smt: remove gulag["..utils.to_str(self:name()).."] exc["..utils.to_str(self.exclusives).."] nexc["..utils.to_str(self.gulag.capacity_non_exclusive).."]")
		self.exclusives = 0
		self.gulag.capacity_non_exclusive = self.exclusives
		--self:show_smart_debug_spot(false)
	end
end

-- populates the table monster_classes
function se_smart_terrain:fill_monster_classes()
  if not monster_classes then
    monster_classes = {
      [clsid.bloodsucker_s ] = "bloodsucker",
      [clsid.boar_s        ] = "boar",
      [clsid.burer_s       ] = "burer",
      [clsid.cat_s         ] = "cat",
      [clsid.chimera_s     ] = "chimera",
      [clsid.controller_s  ] = "controller",
      [clsid.pseudodog_s   ] = "pseudodog",
      [clsid.psy_dog_s     ] = "psy_dog",
      [clsid.dog_s         ] = "dog",
      [clsid.flesh_s       ] = "flesh",
      [clsid.fracture_s    ] = "fracture",
      [clsid.poltergeist_s ] = "poltergeist",
      [clsid.gigant_s      ] = "pseudo_gigant",
      [clsid.snork_s       ] = "snork",
      [clsid.tushkano_s    ] = "tushkano",
      [clsid.zombie_s      ] = "zombie",
	  --[clsid.werewolf_s		] = "werewolf"--,
	  --[clsid.bibliotekar_s ] = "bibliotekar"
    }
  end
end

-- returns the name of the level at which the smart terrain
function se_smart_terrain:get_level_name()
       return TB3D_Services.get_obj_level(self.m_game_vertex_id)
 end

-- registration of the object in the simulator.
-- simulator called.
function se_smart_terrain:on_register()
  if force_obinder then cse_alife_smart_zone.on_register( self ) end				--110010
  self:register_if_needed()
  self:initialize_if_needed()
end

function se_smart_terrain:register_if_needed()
	if self.registred == true then return end										--' If you have already registered then do nothing.
	if self and self.name then
		local level_name = self:get_level_name()
		if level_name ~= "" then
			--TB3D_Services.packet_alert("smrt ter: reg if needed["..self:name().."] ["..level_name.."]")
			self.registred = true
			if self.disabled then			-- DEBUG
				TB3D_Services.packet_alert("smrt ter: reg if needed["..self:name().."] disabled")
				return
			end
			self:fill_monster_classes()
			if not self.gparams.preset_name then
				self.gparams.preset_name = level_name
			end
			db.set_smart_terrain(level_name, self)		--109976
			--if self.gparams.respawn then
				--db.add_respawn(self.gparams.respawn, self)
			--end
			self.gulag:load_jobs()
			if self.gulag_working then
				self.gulag:initialize()
			end
			if TB3D_Modders.use_sim_statistics then sim_statistic.reinit() end
			-- Register in task manager
			task_manager.get_random_task():register_target(self)
			--TB3D_Services.packet_alert("smrt ter: reg if needed["..self:name().."] ["..level_name.."] done")
		end
	end
end

-- de-registration of the object in the simulator.
-- simulator called.
function se_smart_terrain:on_unregister()
	--TB3D_Services.packet_alert("smart terrain: net destroy")
	if TB3D_Modders.use_destroy_message then TB3D_Services.packet_alert("smrt ter: on_unregister["..self:name().."]") end
	if force_obinder then cse_alife_smart_zone.on_unregister( self ) end			--110010
	db.remove_smart_terrain(self)			--109976
	--if self.gparams and self.gparams.respawn then
		--db.del_respawn(self.gparams.respawn)
	--end
	--db.actor_proxy:deinit()				--109974
	if TB3D_Modders.use_destroy_message then TB3D_Services.packet_alert("smrt ter: on_unregister["..self:name().."] done") end
	--TB3D_Services.packet_alert("smart terrain: net destroy done")
end

-- spawner cause if configured.
function se_smart_terrain:call_respawn()
  if self.gparams.respawn then
    se_respawn.spawn( self.gparams.respawn )
  end
end

-- returns a string taken groups and the ranks
function se_smart_terrain:stat_get_accepted_communities()
  local comms = {}
  -- from preset
  local iniFileName = "misc\\" .. self.gparams.type .. ".ltx"
  --local ltx         = ini_file( iniFileName )
  local preset_name = self.gparams.preset_name
  if iniLineSectionExist( preset_name, iniFileName ) then
    local result, field, str
    local n = iniLinesCount( preset_name, iniFileName )
    for i = 0, n-1 do
      result, field, str = getIniLine( preset_name, i, "", "", iniFileName )
      if not self.accepted_communities or self.accepted_communities[field] then
        comms[field] = str
      end
    end
  end
  -- from custom data
  if self.accepted_communities then
    for comm, v in pairs( self.accepted_communities ) do
      if not comms[comm] then
        comms[comm] = "all"
      end
    end
  end
  -- prepare return
  local s = ""
  for comm, ranks in pairs( comms ) do
    s = s .. comm .. "(" .. ranks .. "),"
  end
  return s
end

-- output statistics smarts
function se_smart_terrain:stat()
  local s = self:get_level_name() .. " " .. self:name()
  local pop   = self.gulag:get_population()
  local cap   = self.gulag.capacity
  local avail = self:is_gulag_available()
  if avail then
    s = s .. " enabled "
  else
    s = s .. " disabled "
  end
  s = s .. pop .. " " .. cap .. " " .. self:stat_get_accepted_communities()
  --printf( s )
--  for id, npc_info in pairs( self.npc_info ) do
--    printf( "    %s", npc_info.name )
--  end
  return avail, pop, cap
end

-- Update.
-- Online, invoked through binder.
-- Can also cause a force of xr_effects
-- If the men in the gulag are no more or conditions of existence of the gulag are not met, then remove the gulag.
function se_smart_terrain:update()
	if _g.is_disconnecting then return end			--110010
	if self and self.id then
		if force_obinder then cse_alife_smart_zone.update( self ) end				--110010
		--smart_debug.ShowSmartInfo(self.id, self:name(), self:is_gulag_available(), self.gulag_working, self:get_level_name(),
		--r_str(self:spawn_ini(), "smart_terrain", "communities"), r_str(self:spawn_ini(), "smart_terrain", "cond"))
		if not self.gulag_working then
			return
		end
		--self:initialize_if_needed()
		if self:is_gulag_available() then
			if self.check_time < game.get_game_time() then
				self.check_time = game.get_game_time() + check_period
				--' check never got there someone had already leave
				for id, npc_info in pairs( self.npc_info ) do
					if npc_info.se_obj then
						if npc_info.cond and xr_logic.pick_section_from_condlist( db.actor, npc_info.se_obj, npc_info.cond ) == nil then
							--if TB3D_Modders.use_smh1_message then
								--TB3D_Services.packet_alert("smt: update id["..utils.to_str(self.id).."] unregistered")
							--end
							self:unregister_npc( npc_info.se_obj )
						end
					end
				end
				if (self.gulag.get_population) and self.gulag:get_population() == 0 then
					--smart_debug.remove_mapspots(self.id)
					self:remove_gulag()		--(true) = disable for debug
				else
					if (self.gulag.update) then self.gulag:update() end
				end
			end
		else
			--smart_debug.remove_mapspots(self.id)
			self:remove_gulag()		--(true) = disable for debug
		end
	else
		TB3D_Services.packet_alert("smt: update id[no self or self.id]")
	end
end

--==========  Kamikazze ==========
function on_death( obj_id )
	if obj_id then
		local obj = nil
		if TB3D_Modders.use_smh1_message then TB3D_Services.packet_alert("SMT: on_death["..utils.to_str(obj_id).."] start") end
		local strn_id = get_strn(obj_id)
		if strn_id and strn_id.gulag then
			if TB3D_Modders.use_smh1_message then
				if alife() then
					obj = alife():object(obj_id)
					if obj then	TB3D_Services.packet_alert("SMT: on_death clearing obj["..utils.to_str(obj:name()).."]")	end
				end
				TB3D_Services.packet_alert("SMT: on_death obj["..utils.to_str(obj_id).."] cleared")
			end
			strn_id.gulag:clear_dead(obj_id)
		else
			if alife() then
				obj = alife():object(obj_id)
				if obj then
					if TB3D_Modders.use_smh1_message then TB3D_Services.packet_alert("SMT: on_death strn nil for obj["..utils.to_str(obj:name()).."]") end
					--alife():release(obj)		--causes instant vanish on death, rely on fixer/pop control at spawn
				else
					if TB3D_Modders.use_smh1_message then TB3D_Services.packet_alert("SMART TERRAIN: on_death, strn nil and no object for["..utils.to_str(obj_id).."]") end
				end
			end
		end
	else
		if TB3D_Modders.use_smh1_message then TB3D_Services.packet_alert("SMT: error on_death[NIL OBJ_ID]") end
	end
	if TB3D_Modders.use_smh1_message then TB3D_Services.info_alert("SMT: on_death done") end
end

--[[------- original unregister_npc(npc) called from se_stalker ----- !!!!TB3D  called on disconnect, will cause CTDs !!!
function unregister_npc(obj_id)
	if TB3D_Modders.use_smh3_message == true then TB3D_Services.packet_alert("SMT: call to original unregister_npc") end
	if obj_id then
		local obj
		if alife() then obj = alife():object(obj_id) end
		local object_id = get_strn(obj_id)								--returns the obj or nil
		if object_id and object_id.gulag then
			if TB3D_Modders.use_smh3_message == true then TB3D_Services.packet_alert("SMT: call to original unregister_npc["..utils.to_str(obj:name()).."] clear dead!!!!!!!!") end
			object_id.gulag:clear_dead(obj_id)
		elseif obj then --and not string_find(obj:name(), "respawn") then
			if _g.is_disconnecting == false then
			--if TB3D_Modders.use_smh3_message == true then
				TB3D_Services.packet_alert("SMT: call to original unregister_npc["..utils.to_str(obj:name()).."] cleared!!!!!!!!")
			--end
			--alife():release(obj)		--NOT ok here as game is disconnecting and legacy npc cause CTDs
			end
		end
	else
		TB3D_Services.packet_alert("SMT: call to original unregister_npc obj_id[nil] !!!!!!!!")
	end
	if TB3D_Modders.use_smh3_message == true then TB3D_Services.packet_alert("SMT: call to original unregister_npc done") end
end
--]]-------moved to se stalker 109950

--------------------
-- read the section [smart_terrains], called by se_stalker and se_monster
-- caused by objects that can go under smart terrain
function read_smart_terrain_conditions( self )
  if self.ini and self.ini:section_exist( smart_section ) then
    local conds = {}
    local accepts = false
    local n = self.ini:line_count( smart_section )
    local result, field, str = self.ini:r_line( smart_section, 0, "", "" )
    if n > 0 then
      for i = 0, n-1 do
        result, field, str = self.ini:r_line( smart_section, i, "", "" )
        --str=string_gsub(str,"{\-aes_arrive_to}","true")										--109950 does not exist in all.spawn
        conds[field] = xr_logic.parse_condlist(self, smart_section, field, str)
      end
      return conds
    end
  end
  return nil
end

function get_strn(sobj_id)
	local obj
	local sim = alife()
	if sobj_id then
		if sim then obj = sim:object( sobj_id ) end
		if obj then
			if TB3D_Modders.use_smh3_message then TB3D_Services.packet_alert("SMT: get strn try smart for obj["..utils.to_str(sobj_id).."]["..obj:name().."]") end
			if obj.smart_terrain_id then
				strn_id = obj:smart_terrain_id()
				if strn_id and strn_id ~= expendable_object then obj = sim:object(strn_id) end
				if obj then return obj end
			end
			if TB3D_Modders.use_smh3_message then TB3D_Services.info_alert("SMT: get strn no smart for obj["..utils.to_str(sobj_id).."]") end
		end
		if TB3D_Modders.use_smh3_message then TB3D_Services.info_alert("SMT: get strn no smart for sobj["..utils.to_str(sobj_id).."]") end
	end
	return nil
end

--------------------
-- Displays statistics for all smarts in the simulation
function stat()
  --[[printf( "--------------- Smart terrains statistics START ----------------------" )
  local jobs, jobs_in_avail, occupied
  local level_stats = {}
  for level_name, t in pairs( db.smart_terrains ) do
    jobs, jobs_in_avail, occupied = 0, 0, 0
    for id, strn in pairs( t ) do
      local avail, pop, cap = strn:stat()
      jobs       = jobs     + cap
      occupied   = occupied + pop
      if avail then
        jobs_in_avail = jobs_in_avail + cap
      end
    end
    local l = {}
    level_stats[level_name] = l
    l.jobs          = jobs
    l.occupied      = occupied
    l.jobs_in_avail = jobs_in_avail
  end
  jobs, jobs_in_avail, occupied = 0, 0, 0
  --printf("")
  for level_name, l in pairs( level_stats ) do
    --printf( "Level %s :", level_name )
    --printf( "    Jobs in all smart terrains : %d",       l.jobs )
    --printf( "    Jobs in available smart terrains : %d", l.jobs_in_avail )
    --printf( "    Occupied jobs : %d",                    l.occupied )
    jobs          = jobs          + l.jobs
    jobs_in_avail = jobs_in_avail + l.jobs_in_avail
    occupied      = occupied      + l.occupied
  end
  --printf( "All levels:" )
  --printf( "    Jobs in all smart terrains : %d",       jobs )
  --printf( "    Jobs in available smart terrains : %d", jobs_in_avail )
  --printf( "    Occupied jobs : %d",                    occupied )
  --]]printf( "--------------- Smart terrains statistics END ------------------------" )
end
