-- TB3D 1.1.0.0.1.0 db calls, db.spawn_heli/destroy_heli, clear callbacks
function my_ver() return "1.1.0.0.1.0" end
--[[------------------------------------------------------------------------------------------------
Helicoter binding
Chugai Alexander
Make:- settings in the ltx
--------------------------------------------------------------------------------------------------]]
local force_obinder = TB3D_Modders.use_mgun_obinder				--110010, calls into game binder (alife)
if force_binder == nil then force_binder = true end

function bind( obj )
--    printf( "BIND HELICOPTER id=%d", obj:id() )
   	local ini = obj:spawn_ini()
   	if ini and ini:section_exist("logic") then
		obj:bind_object( heli_binder( obj, ini ) )
	end
end

---------------------------------------------------------------------------------------------
-- Binder helicopters
---------------------------------------------------------------------------------------------
class "heli_binder" ( object_binder )

function heli_binder:__init( obj, ini ) super( obj )
	self.ini         = ini
	self.initialized = false
	self.loaded      = false
end

function heli_binder:reload( section )
	if force_obinder then object_binder.reload( self, section ) end		--110010
end

function heli_binder:reinit()
	if force_obinder then object_binder.reinit( self ) end			--110010
	db.init_my_storage(self.object)
	self.st = db.storage[self.object:id()]
	self.heliObject = self.object:get_helicopter()
	self.object:set_callback( callback.helicopter_on_point, self.on_point, self )
	self.object:set_callback( callback.helicopter_on_hit,   self.on_hit,   self )
	self.st.combat = heli_combat.heli_combat( self.object, self.heliObject )
	self.last_hit_snd_timeout = 0
	local ltx = system_ini()
	self.flame_start_health   = utils.cfg_get_number( ltx, "helicopter", "flame_start_health", self.object, true )
	self.st.flame_start_snd   = xr_sound.get_sound_object("heli_explosion", "random")
	self.st.last_alt       = self.heliObject:GetRealAltitude()	-- the case load
	self.st.alt_check_time = time_global() + 1000
end

function heli_binder:update( delta )
	if _g.is_disconnecting then return end
	if TB3D_Modders.Global_Debug then TB3D_Services.packet_alert("bind      heli: update["..game.get_game_time():timeToString(game.CTime.TimeToMilisecs).."] delta["..utils.to_str(delta).."]") end
	if force_obinder then object_binder.update( self, delta ) end		--110010
	--printf( "heli_binder update" )
	--printf( "%d", self.object:level_vertex_light( db.actor:level_vertex_id() ) )
	if not self.initialized and db.actor then
		self.initialized = true
		xr_logic.initialize_obj( self.object, self.st, self.loaded, db.actor, modules.stype_heli )
	end
	self.object:info_clear()
	if self.st.active_section ~= nil then
		xr_logic.issue_event( self.object, self.st[self.st.active_scheme], "update", delta )
	end
	local active_section = db.storage[self.object:id()].active_section
	if active_section then
		self.object:info_add('section -- ' .. active_section)
	end
	self:check_health()
	if db.storage[self.object:id()].alive == true and dmx_cars.actor_inside_btr() then
		if dmx_cars.actor_target(self.object) then
			dmx_cars.set_target(self.object:id())
		end
	end	
	if TB3D_Modders.Global_Debug then TB3D_Services.packet_alert("bind      heli: update["..game.get_game_time():timeToString(game.CTime.TimeToMilisecs).."] done") end
end

function heli_binder:net_spawn( data )
	if force_obinder and not object_binder.net_spawn( self, data ) then return false end			--110010
	db.add_heli( self.object )
	if (news_main and news_main.on_heli_seen and self.object) then
		news_main.on_heli_seen(self.object)
	end
	return true
end

function heli_binder:net_destroy()
	--TB3D_Services.packet_alert("bind heli: net destroy")
	if TB3D_Modders.use_destroy_message then TB3D_Services.packet_alert("heli binder: net destroy["..utils.to_str(self.object:name()).."] section["..self.object:section().."]") end
	self.object:set_callback( callback.helicopter_on_point, nil )		--109990
	self.object:set_callback( callback.helicopter_on_hit, nil )		--109990
	db.del_heli( self.object )
	if force_obinder then object_binder.net_destroy( self ) end		--110010
	if TB3D_Modders.use_destroy_message then TB3D_Services.packet_alert("heli binder: net destroy["..utils.to_str(self.object:name()).."] done") end
	--TB3D_Services.packet_alert("bind heli: net destroy done")
end

function heli_binder:net_save_relevant()
	return true
end

function heli_binder:save( packet )
	if force_obinder then object_binder.save( self, packet ) end			--110010
	--printf( "heli_binder: save")
	xr_logic.save_obj( self.object, packet )
	self.st.combat:save( packet )
end

function heli_binder:load( packet )
	self.loaded = true
	--printf("generic_object_binder:load(): self.object:name()='%s'", self.object:name())
	if force_obinder then object_binder.load( self, packet ) end			--110010
	--printf( "heli_binder: load")
	xr_logic.load_obj( self.object, packet )
	self.st.combat:load( packet )
end

function heli_binder:check_health()
	local heli = self.heliObject
	--printf( "heli health: %d", heli:GetfHealth() )
	if not heli.m_dead then
		local health = get_heli_health( self.heliObject, self.st )
		if health < self.flame_start_health and not heli.m_flame_started then
			heli_start_flame( self.object )
			heli_snd.play_snd( self.st, heli_snd.snd_damaged, 3 )
		end
		if health <= 0.005 and not self.st.immortal then
			heli_die( self.object )
			heli_snd.play_snd( self.st, heli_snd.snd_down, 4 )
		end
	end
end

------------------------------ callbacks ---------------------------------
function heli_binder:on_hit( power, impulse, hit_type, enemy_id )
	--printf( "heli_binder: hit callback")
	local enemy        = level.object_by_id( enemy_id )
	if enemy then
		local enemy_cls_id = enemy:clsid()
	-- if the abuser is an actor or a stalker, then make it your enemy
	if enemy_cls_id == clsid.actor or enemy_cls_id == clsid.script_stalker then
		--if not self.st.combat.enemy_id then
			--self.st.combat.enemy_id = enemy_id
		--end
		if self.st.hit then
			xr_logic.issue_event( self.object, self.st.hit, "hit_callback", self.object, power, nil, enemy, nil )
			end
		end
	end
	-- pilots swear on the radio
	if self.last_hit_snd_timeout < time_global() then
		heli_snd.play_snd( self.st, heli_snd.snd_hit, 2 )
		self.last_hit_snd_timeout = time_global() + math.random( 4000, 8000 )
	end
end

function heli_binder:on_point( distance, position, path_idx )
	if self.st.active_section ~= nil then
		xr_logic.issue_event( self.object, self.st[self.st.active_scheme], "waypoint_callback", self.object, nil, path_idx )
	end
end

--------------------------------------------------------------------------
function get_heli_health( heli, st )
	local health
	if st.invulnerable then
		health = 1
		heli:SetfHealth( health )
	else
		health = heli:GetfHealth()
		if health < 0 then
			heli:SetfHealth( 0 )
			health = 0
		end
	end
	return health
end

function is_heli_alive( obj )
	return get_heli_health( obj:get_helicopter(), db.storage[obj:id()] ) > 0.005
end

function heli_start_flame( obj )
	obj:get_helicopter():StartFlame()
	db.storage[obj:id()].flame_start_snd:play( obj )
	if (news_main and news_main.on_heli_flame and obj) then
		news_main.on_heli_flame(obj)
	end
end

function heli_die( obj )
	local heli = obj:get_helicopter()
	local st   = db.storage[obj:id()]
	heli:Die()
	--db.del_heli( obj )
	st.last_alt       = heli:GetRealAltitude()
	st.alt_check_time = time_global() + 1000
	if (news_main and news_main.on_heli_die and obj) then
		news_main.on_heli_die(obj)
	end
end
 