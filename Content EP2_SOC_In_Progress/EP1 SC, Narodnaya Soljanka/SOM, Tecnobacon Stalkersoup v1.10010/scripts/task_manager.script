-- TB3D 1.0.9.9.9.9 new rep system, give talk message, restored breaks, kill stalker, atp, debug, oau_watchdog, esc2_st_fabric,
-- targets_killed, translate, task complete, cleanup
function my_ver() return "1.0.9.9.9.9" end

local table_remove = table.remove
local string_len = string.len
local string_sub = string.sub
local string_find = string.find		---!!!!TB3D
local math_random = math.random
local translate = game.translate_string

local random_task = nil

local parent_by_story = {
  [003] = "trader",
  [500] = "barman",
  [902] = "ecolog",
  [507] = "dolg",
  [707] = "freedom",
  [006] = "wolf",
  [004] = "shustriy",
  [510] = "drunk_dolg",
  [504] = "hunter",
  [518] = "zastava_commander",
  [506] = "petrenko",
  [607] = "lisiy",
  [515] = "mercenary",
  [9613] = "green"
}

local story_by_parent = {
  trader            = 003,
  barman            = 500,
  ecolog            = 902,
  dolg            = 507,
  freedom           = 707,
  wolf            = 006,
  shustriy          = 004,
  drunk_dolg          = 510,
  hunter            = 504,
  zastava_commander     = 518,
  petrenko          = 506,
  lisiy           = 607,
  mercenary         = 515,
  green    = 9613
}

local return_task_by_type = {
  eliminate_lager = "return_for_reward",
  defend_lager = "return_for_reward",
  kill_stalker = "return_for_reward",
  artefact = "return_for_reward_bring",
  monster_part = "return_for_reward_bring",
  find_item = "return_for_reward_bring"}


local hash_to_id={}
local id_to_hash={}
local ct_to_hash={}
local hash_to_ct={}
-- a hash function for strings (see the literature on the subject of optimal)
function stringhash(str)
	local mpl=1
	local hash=0
	local val=0
	for i=1,string_len(str),1 do
		val=string.byte(string_sub(str,i,i))
		hash=hash+mpl*val
		mpl=mpl*2
		if mpl==512 then mpl=1 end
	end
	return bit_and(hash,value_65535)
end

class "CRandomTask"
function CRandomTask:__init()
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: init") end
	--' At Designer proofreads LTX and create a piece of quests.
	self.task_ini = ini_file("misc\\task_manager.ltx")
	self.task_phrase_id = 100
	--' We iterate over all settings phrases
	if not self.task_ini:section_exist("list") then
		if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: There is no section [list] in task_manager.ltx") end
	end
	local n = self.task_ini:line_count("list")
	local id, value = "",""
	local category = ""
	local hash = ""
	local curr_task_info = {}
	local ct= ""
	local cthash=""
	local sss = nil
	local reward_info=nil
	--' initial setup
	self.task_info = {}
	for i=0,n-1 do
		result, id, value = self.task_ini:r_line("list",i,"","")
		hash=stringhash(id)
		if hash_to_id[hash] then
			if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: Collision! Hash["..utils.to_strn(hash).."] id1["..utils.to_strn(hash_to_id[hash]).."] id2["..utils.to_strn(id).."]") end
		end
		hash_to_id[hash]=id
		id_to_hash[id]=hash
		-- TB3D_Services.info_alert("id:"..id.." hash:"..hash)
		if not self.task_ini:section_exist(id) then
			if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: There is no section ["..utils.to_str(id).."] in task_manager.ltx") end
		end   
		self.task_info[tostring(id)] = {}
		curr_task_info = self.task_info[tostring(id)]
		if not self.task_ini:line_exist(id, "type") then
			if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: Task manager error: no type in section ["..utils.to_str(id).."]") end
		end
		curr_task_info.type = self.task_ini:r_string(id, "type")			
		curr_task_info.name = id
		if self.task_ini:line_exist(id, "parent") then
			curr_task_info.parent = self.task_ini:r_string(id, "parent")
			curr_task_info.complex_type = curr_task_info.type .. "_" .. self.task_info[id].parent
		else
			curr_task_info.parent = "nil"
			curr_task_info.complex_type = curr_task_info.type
		end
		ct=curr_task_info.complex_type
		cthash=stringhash(ct)
		if hash_to_ct[cthash] and hash_to_ct[cthash]~=ct then
			if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: Collision! Hash["..utils.to_strn(hash).."] id1["..utils.to_strn(hash_to_id[hash]).."] id2["..utils.to_strn(id).."]") end
		end
		hash_to_ct[cthash]=ct
		ct_to_hash[ct]=cthash
		if self.task_ini:line_exist(id, "target") then
			curr_task_info.target = self.task_ini:r_string(id, "target")
		end
		if self.task_ini:line_exist(id, "text") then
			curr_task_info.text = self.task_ini:r_string(id, "text")
		end
		if self.task_ini:line_exist(id, "description") then
			curr_task_info.description	= self.task_ini:r_string(id, "description")				
		end
		curr_task_info.time = utils.cfg_get_number(self.task_ini, id, "time", nil, false)
		curr_task_info.idle_time = utils.cfg_get_number(self.task_ini, id, "idle_time", nil, false, 24*60*60) --' The time between the issuance of the job (in gaming seconds)
		curr_task_info.prior = utils.cfg_get_number(self.task_ini, id, "prior", nil, false, 0) --' Priority quest available quests are given the lowest priority
		if self.task_ini:line_exist(id, "init_condition") then
			curr_task_info.init_condition = xr_logic.parse_condlist(db.actor, "task_manager", "init_condition", self.task_ini:r_string(id, "init_condition"))
		end
		sss = utils.cfg_get_string(self.task_ini, id, "reward_item", nil, false, "")
		if sss ~= nil then
			curr_task_info.reward_item = se_respawn.parse_names(sss) 
		else
			curr_task_info.reward_item = sss
		end
		curr_task_info.reward_money = utils.cfg_get_number(self.task_ini, id, "reward_money", nil, false)		
		-- Award Information
		--TB3D_Services.info_alert("reward info read")
		reward_info=utils.cfg_get_string(self.task_ini, id, "reward_info", nil, false,"")   
		if reward_info=="" then reward_info=nil end
		curr_task_info.reward_info = reward_info
		if reward_info then
			self:read_info_reward_section(self.task_ini,reward_info,curr_task_info)
		end
		--TB3D_Services.info_alert("reward info read done")
		-- Dialog for Quest victims
		curr_task_info.target_dialog = utils.cfg_get_string(self.task_ini, id, "target_dialog", nil, false,"")
		----------------------
		if self.task_ini:line_exist(id, "community") then
			curr_task_info.community = self.task_ini:r_string(id, "community")
		end		
		curr_task_info.reward_rank = utils.cfg_get_number(self.task_ini, id, "reward_rank", nil, false, 0)
		curr_task_info.reward_reputation = utils.cfg_get_number(self.task_ini, id, "reward_reputation", nil, false)
		curr_task_info.reward_relation = parse_key_value(utils.cfg_get_string(self.task_ini, id, "reward_relation", nil, false, ""))
		if self.task_ini:line_exist(id, "condlist") then
			curr_task_info.condlist = xr_logic.parse_condlist(db.actor, "task_manager", "condlist", self.task_ini:r_string(id, "condlist"))
		else
			curr_task_info.condlist = xr_logic.parse_condlist(db.actor, "task_manager", "condlist", "true")
		end		
		curr_task_info.need_return = utils.cfg_get_bool(self.task_ini, id, "need_return", nil, false, true)
		curr_task_info.init_phrase_id = self:gen_phrase_id()
		curr_task_info.desc_phrase_id = self:gen_phrase_id()
		curr_task_info.yes_phrase_id = self:gen_phrase_id()
		curr_task_info.no_phrase_id = self:gen_phrase_id()
		curr_task_info.completed_phrase_id = self:gen_phrase_id()
		--' By default, the quest is available for the issuance of
		curr_task_info.enabled = true
		--' Whether the quest for their properties. The default is always available.
		--' This option depends on the objectives for quests and the quest is triggered if prekondishn
		curr_task_info.enabled_props		= false
		--' The status of the quest can be: "normal", "selected", "completed", "refused", "failed", "rewarded"
		curr_task_info.status = "normal"
	end
	--' Creation of additional associative table for easy retrieval
	self.task_id_by_type = {}
	self.task_id_by_parent = {}
	self.task_id_by_yes_phrase_id = {}
	self.task_id_by_completed_phrase_id = {}
	self.task_id_by_desc_phrase_id = {}
	self.task_id_by_init_phrase_id = {}
	self.active_task_by_type = {}
	self.task_id_self_inited = {}
	for k,v in pairs(self.task_info) do
		--' By type of quest
		if self.task_id_by_type[v.type] == nil then
			self.task_id_by_type[v.type] = {}
		end
		self.task_id_by_type[v.type][#self.task_id_by_type[v.type]+1] = k
		--' By type of vendor
		if self.task_id_by_parent[v.parent] == nil then
			self.task_id_by_parent[v.parent] = {}
		end
		self.task_id_by_parent[v.parent][#self.task_id_by_parent[v.parent]+1] = k
		--' By id phrases consent to the quest
		self.task_id_by_yes_phrase_id[tostring(v.yes_phrase_id)] = k
		self.task_id_by_completed_phrase_id[v.completed_phrase_id] = k
		self.task_id_by_desc_phrase_id[v.desc_phrase_id] = k
		-- TB3D_Services.info_alert("task "..v.complex_type .. " id " .. v.completed_phrase_id)
		--' By id phrases issuance quest.
		self.task_id_by_init_phrase_id[tostring(v.init_phrase_id)] = k
		--' By samovydavaemosti
		if v.init_condition ~= nil then
			self.task_id_self_inited[#self.task_id_self_inited+1] = k
		end
	end
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: init done") end
end

--------- Award Information --------
function CRandomTask:read_info_reward_section(ini,sect,container)
	if TB3D_Modders.use_task_message == true then TB3D_Services.packet_alert("TASK MGR: read info reward") end
	--TB3D_Services.info_alert("reading section "..sect)
	--container.reward_info_portion=utils.cfg_get_string(ini,sect,"info_portion",nil,true,"")
	local rip = utils.cfg_get_string(ini,sect,"info_portion",nil,true,"")
	if rip ~= nil then
		container.reward_info_portion = se_respawn.parse_names(rip)
	else
		container.reward_info_portion = rip
	end
	container.reward_info_dialog={}
	local phr=1
	local phrase_id=nil
	while true do
		phrase_id=utils.cfg_get_string(ini,sect,"phrase_"..phr,nil,false,"")
		if phrase_id==nil or phrase_id=="" then break end
		if TB3D_Modders.use_info_message then TB3D_Services.packet_alert("task manager: reward info sect["..sect.."] phrase_"..phr.." is ["..phrase_id.."]") end
		container.reward_info_dialog[#container.reward_info_dialog+1] = phrase_id
		phr=phr+1
	end  
	if TB3D_Modders.use_task_message == true then TB3D_Services.packet_alert("TASK MGR: read info reward done") end
end
--------------------------------------


    --' The status of the quest can be: "normal", "selected", "completed", "refused", "failed", "rewarded"
-- Well and good. We write down his number. - Sevenfold savings.
local status_to_num={normal=0, selected=1, completed=2, refused=3, 
  failed=4, rewarded=5}
local num_to_status={[0]="normal", [1]="selected", [2]="completed", [3]="refused", 
  [4]="failed", [5]="rewarded"}
local new_pack = 255
-- We will not record a task id and its hash - sevenfold savings.
function CRandomTask:save(p)
	if TB3D_Modders.use_packet_message == true then
		TB3D_Services.info_alert("TASK MGR: save packet")
	end
	p:w_u8(new_pack)	-- Indication that this is a new version of the format.
	local i = 0
	for k,v in pairs(self.task_info) do	i = i + 1 end	--' get the number of entries
	p:w_u8(i)
	TB3D_Services.packet_alert("TASK MGR: save new packet tasks["..utils.to_str(i).."]")
	for k,v in pairs(self.task_info) do
		if not id_to_hash[k] then
			if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: Save Cannot find hash for id["..utils.to_str(k).."]") end
		end
		p:w_u16(id_to_hash[k]) 
		p:w_bool(v.enabled) 
		p:w_bool(v.enabled_props)
		if not status_to_num[v.status] then
			if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: Save Wrong status["..utils.to_str(v.status).."] for task["..utils.to_str(k).."]") end
		end
		p:w_u8(status_to_num[v.status])
		p:w_u32(v.selected_target or -1)
		utils.w_CTime(p, v.last_task_time)
	end
	--' The same procedure with active dragging
	i = 0
	for k,v in pairs(self.active_task_by_type) do i = i + 1	end
	p:w_u8(i)
	TB3D_Services.packet_alert("TASK MGR: save new packet active tasks["..utils.to_str(i).."]")
	for k,v in pairs(self.active_task_by_type) do
		if not ct_to_hash[k] then
			if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: Save Cannot find hash for complex type["..utils.to_str(k).."]") end
		end
		p:w_u16(ct_to_hash[k]) 
		if not id_to_hash[v] then
			if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: Save Cannot find hash for task id["..utils.to_str(v).."]") end
		end
		p:w_u16(id_to_hash[v])
	end
end

--' Download
function CRandomTask:load(p)
	if TB3D_Modders.use_packet_message == true then TB3D_Services.info_alert("TASK MGR: load packet") end
	if p then
		local rt0=p:r_tell()				--get the packet size
		if not rt0 then
			if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: load packet rt0[nil] !!!!!") end
			return
		end
		if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: load packet size["..utils.to_str(rt0).."]") end
		local i = p:r_u8()			--can be: ('new_pack' indicating new packet format) or (number of entries in old packets)
		if not i then
			if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: load packet i[nil] !!!!!") end
			return
		end
		--TB3D_Services.packet_alert("TASK MGR: load packet val1["..utils.to_str(i).."] size["..utils.to_str(rt0).."]")
		local selected_target = 0
		local id = ""
		local hash = "" 
		if i<new_pack then
			TB3D_Services.packet_alert("TASK MGR: load old packet tasks["..utils.to_str(i).."]")
			for k = 1,i do
				id = p:r_stringZ()
				if id ~= nil and self.task_info[id] ~= nil then
					self.task_info[id].enabled = p:r_bool()
					self.task_info[id].enabled_props = p:r_bool()
					self.task_info[id].status = p:r_stringZ()
					selected_target = p:r_u32()
					if selected_target ~= -1 then
						self.task_info[id].selected_target = selected_target
					end
					self.task_info[id].last_task_time = utils.r_CTime(p)
				end
			end
			i = p:r_u8()  
			TB3D_Services.packet_alert("TASK MGR: load old packet active["..utils.to_str(i).."]")
			for k = 1,i do
				id = p:r_stringZ()
				self.active_task_by_type[id] = p:r_stringZ()  
			end
		else
			i=p:r_u8()
			TB3D_Services.packet_alert("TASK MGR: load new packet tasks["..utils.to_str(i).."]")
			for k = 1,i do
				hash = p:r_u16() 
				id=hash_to_id[hash]
				if id then
					self.task_info[id].enabled = p:r_bool()
					self.task_info[id].enabled_props = p:r_bool()
					self.task_info[id].status = num_to_status[p:r_u8()]
					selected_target = p:r_u32()
					if selected_target ~= -1 then
						self.task_info[id].selected_target = selected_target
					end
					self.task_info[id].last_task_time = utils.r_CTime(p)
				else
					if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: load Cannot find id for new hash["..hash.."]") end
				end
			end
			i = p:r_u8()  
			TB3D_Services.packet_alert("TASK MGR: load new packet active["..utils.to_str(i).."]")
			for k = 1,i do
				hash = p:r_u16()
				id=hash_to_ct[hash]
				if id then
					hash=p:r_u16()
					self.active_task_by_type[id] = hash_to_id[hash]
					if not self.active_task_by_type[id] then
						if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: load Cannot find task id for new hash["..utils.to_str(hash).."]") end
					end
				else
					if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: load Cannot find complex type for new hash["..utils.to_str(hash).."]") end
				end
			end
		end
	else
		if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: load new packet p[nil] !!!!!") end
	end
	if TB3D_Modders.use_packet_message == true then TB3D_Services.info_alert("TASK MGR: load packet done") end
end

--' Unique ID Generator for phrases
function CRandomTask:gen_phrase_id()
	self.task_phrase_id = self.task_phrase_id + 1
	return tostring(self.task_phrase_id)
end

--' Returns the ID of the vendor with whom we are talking
function CRandomTask:get_parent(npc)
	local story_id = npc:story_id()
	if parent_by_story[story_id] == nil then
		if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: Task manager error: wrong parent story_id = ["..utils.to_str(story_id).."]") end
	end
	return parent_by_story[story_id]
end

--' Can the vendor give quest
function CRandomTask:parent_can_task(actor, npc, p1, p2, p3)
  local parent = self:get_parent(npc)
  local avail = false
  if parent then
	  self:task_avail(actor, npc, nil, nil, nil, "reset")
	  for k,v in pairs(self.task_id_by_parent[parent]) do
		if self:task_avail(actor, npc, nil, nil, self.task_info[v].init_phrase_id, true) then
		  avail = true
		end
	  end
  end
  return avail
end

--' Is there a player at least one task from this vendor
function CRandomTask:active_parent_task(actor, npc)
  local parent = self:get_parent(npc)
  if parent then
	  for k,v in pairs(self.active_task_by_type) do
		--printf("active_parent_task: %s", tostring(v))
		--printf("active_parent_task: parent = %s", tostring(self.task_info[v].parent))
		--printf("active_parent_task: status = %s", tostring(self.task_info[v].status))
		if self.task_info and self.task_info[v] then
			if self.task_info[v].parent == parent and
				(self.task_info[v].status == "selected" or
				self.task_info[v].status == "completed")
				then
				return true
			end
		end       
	  end
  end
  return false
end

--' Is there a player finished the job (which have only to pass)
function CRandomTask:have_completed_job(actor, npc)
  if TB3D_Modders.show_tables == true then show_tables(self.active_task_by_type, nil, "task mgr") end
  local parent = self:get_parent(npc)
  if parent then
	  for k,v in pairs(self.active_task_by_type) do
		--printf("have_completed_job: %s", tostring(v))
		--printf("have_completed_job: parent = %s", tostring(self.task_info[v].parent))
		--printf("have_completed_job: status = %s", tostring(self.task_info[v].status))
		if self.task_info[v].parent == parent and
		   self.task_info[v].status == "completed"
		then
		  return true
		end       
	  end
  end
  return false
end

--' Issue quest player
function CRandomTask:action_give_task(actor, npc, p1, p2)
	local task = CGameTask()
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: give random task") end
	local task_id=self.task_id_by_yes_phrase_id[p2]
	local task_desc = self.task_info[task_id]
	task:load(task_desc.complex_type)
	task:set_title(task_desc.type)
	local oo = task:get_objective(0)
	oo:set_article_id(task_desc.description)
	local objective = SGameTaskObjective(task,1)
	objective:set_description(task_desc.name)
	if task_desc.target_objects ~= nil then	--' Select the current target Quest
		self.task_info[task_id].selected_target = task_desc.target_objects[math_random(#task_desc.target_objects)]
		--printf("TARGET DEBUG INFO")
		--printf("selected = %s", tostring(self.task_info[self.task_id_by_yes_phrase_id[p2]].selected_target))
		if TB3D_Modders.show_tables == true then show_tables(task_desc.target_objects, nil, "task mgr") end
	end
	if task_desc.type == "eliminate_lager" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("eliminate_lager_location")
		objective:set_object_id(task_desc.selected_target)
	elseif task_desc.type == "defend_lager" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("defend_lager_location")
		objective:set_object_id(task_desc.selected_target)
		local defend_object = alife():object(task_desc.selected_target)
		local sm_ini = defend_object:spawn_ini()
		self.task_info[task_id].defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
	elseif task_desc.type == "kill_stalker" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("kill_stalker_location")
		objective:set_object_id(task_desc.selected_target)
		if task_desc.target_dialog then		-- Add id stalker in the list of targets
			amk_add_target_id_to_kill_targets(task_desc.selected_target,task_desc.target_dialog,task_id)
			TB3D_Services.check_kill_target_spawned(task_desc.selected_target)			--109998, make sure target spawns
		end
	elseif task_desc.type == "find_item" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("find_item_location")
		objective:set_object_id(task_desc.selected_target)
	end
	objective:add_complete_func("task_manager.task_complete")
	task:add_objective(objective)
	if task_desc.need_return then
		objective = SGameTaskObjective(task,2)
		objective:set_description(return_task_by_type[task_desc.type])
		objective:set_map_hint(return_task_by_type[task_desc.type])
		objective:set_map_location("blue_location")
		if not alife():story_object(tonumber(story_by_parent[task_desc.parent])) then
			return 			-- Kvestodatel profits.
		end
		objective:set_object_id(alife():story_object(tonumber(story_by_parent[task_desc.parent])).id)
		task:add_objective(objective)
	end
	local time = 0
	if task_desc.time ~= nil then
		time = task_desc.time * 1000
	end
	db.actor:give_task(task,time,false)
	--' dizable all the other tasks of this type, since a player can not simultaneously have two jobs of the same type.
	self.task_info[self.task_id_by_yes_phrase_id[p2]].status = "selected"
	self.active_task_by_type[task_desc.complex_type] = self.task_id_by_yes_phrase_id[p2]
	for k,v in pairs(self.task_info) do
		if v.complex_type == task_desc.complex_type then
			v.enabled = false
		end
	end
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: give random task done") end
end

--' The refusal of a player quest
function CRandomTask:action_refuse_task(actor, npc, p1, p2)
	local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]
	self.task_info[self.task_id_by_yes_phrase_id[p2]].status = "refused"	--' Make available all the tasks of this type
	amk_remove_target_id_from_kill_targets(self.task_info[self.active_task_by_type[task_desc.complex_type]].selected_target)	-- Remove the target from the list 
	self.task_info[self.active_task_by_type[task_desc.complex_type]].selected_target = nil
	for k,v in pairs(self.task_info) do
		if v.complex_type == task_desc.complex_type then
			v.enabled = true
		end
	end
end

local esc2_spawned
local agro_spawned
local agrou_spawned
local ros_spawned
--' Checks made whether TASK
function CRandomTask:task_complete(p1, p2)
	if db.actor then
		local sel_task = self.task_info[self.active_task_by_type[p1]]
		if sel_task == nil then
			--printf("!!!")
			if TB3D_Modders.show_tables == true then show_tables(self.active_task_by_type, nil, "task mgr") end
			--printf("!!!")
			if TB3D_Modders.show_tables == true then show_tables(self.task_info, nil, "task mgr") end
			--if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: WRONG RANDOM TASK ["..utils.to_str(p1).."] ["..utils.to_str(p2).."]") end
			return false
		end
		if p2 == 0 then
			if not sel_task.need_return and sel_task.status == "completed" then
				self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
				return true
			end
			if sel_task.status == "rewarded" then
				self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
				return true
			end
		elseif p2 == 1 then
			if string_find(p1, "eliminate_lager") ~= nil then
				local oo = alife():object(sel_task.selected_target)
				if oo then
					--TB3D_Services.packet_alert("task mgr: task["..tostring(self.active_task_by_type[p1]).."] target["..utils.to_str(oo:name()).."] pop["..utils.to_str(oo.gulag:get_population_comed()).."]")
					if oo:name() == "esc2_st_fabric" then
						if level:name() == "l01_escape" then
							if esc2_spawned then
								if TB3D_Services.targets_killed(3) > 3 then		--109995
									self.task_info[self.active_task_by_type[p1]].status = "completed"
									return true
								end
							else
								TB3D_Mobs.spawn_quest_bandits(113.044,-7.495,8.628,414741,118,6)
								esc2_spawned = true
							end
						end
					elseif oo:name() == "ros_smart_stalker2" then
						if level:name() == "l06_rostok" then
							if ros_spawned then
								if TB3D_Services.targets_killed(3) > 3 then		--109997
									self.task_info[self.active_task_by_type[p1]].status = "completed"
									return true
								end
							else
								TB3D_Mobs.spawn_quest_bandits(-162.000,0.024,184.062,35434,1329,6)
								ros_spawned = true
							end
						end
					elseif oo:name() == "agr_u_bandits" then
						if level:name() == "l03u_agr_underground" then
							if agrou_spawned then
								if TB3D_Services.targets_killed(3) > 3 then		--109997
									self.task_info[self.active_task_by_type[p1]].status = "completed"
									return true
								end
							else
								TB3D_Mobs.spawn_quest_bandits(-69.827,-6.499,13.221,3459,712,6)
								agrou_spawned = true
							end
						end
					elseif oo:name() == "agr2_bandit_st" then
						if level:name() == "l03_agroprom" then
							if agro_spawned then
								if TB3D_Services.targets_killed(3) > 3 then		--109997
									self.task_info[self.active_task_by_type[p1]].status = "completed"
									return true
								end
							else
								TB3D_Mobs.spawn_quest_bandits(-65.405,0.698,21.058,176079,699,8)
								agro_spawned = true
							end
						end
					elseif oo.gulag:get_population_comed() < 1 then
						self.task_info[self.active_task_by_type[p1]].status = "completed"
						return true
					end
				end
			elseif string_find(p1, "defend_lager") ~= nil then
				--' Quest is made because the raid stopped
				if xr_gulag.getGulagState(sel_task.defend_target) == 0 then
					self.task_info[self.active_task_by_type[p1]].status = "completed"
					--TB3D_Services.info_alert("task mgr: task["..tostring(self.active_task_by_type[p1]).."] completed")
					return true
				end
				--TB3D_Services.info_alert("task mgr: task["..tostring(self.active_task_by_type[p1]).."] not done["..utils.to_str(oo.gulag:get_population_comed()).."]")
			elseif string_find(p1, "kill_stalker") ~= nil then
				local oo = alife():object(sel_task.selected_target)
				--' Verifying bug
--[[				if oo == nil then
					--printf("selected_target = %s", tostring(sel_task.selected_target))
					if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: OBJ = nil for task ["..utils.to_str(self.active_task_by_type[p1]).."]") end
				elseif oo.alive == nil then 
					--printf("OBJ.ALIVE = nil for task %s", tostring(self.active_task_by_type[p1]))
					if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: OBJ.NAME = ["..utils.to_str(obj:name()).."]") end       
				end   ]]--
				if oo == nil or oo.alive == nil or oo:alive() == false then
					-- Stalker killed or missing. Id remove it from the list of goals
					amk_remove_target_id_from_kill_targets(sel_task.selected_target)
					-------------------------------------------------
					self.task_info[self.active_task_by_type[p1]].status = "completed"
					return true
				end
			elseif string_find(p1, "artefact") ~= nil then
				if db.actor:object(sel_task.target) ~= nil then
					self.task_info[self.active_task_by_type[p1]].status = "completed"
					return true
				end
			elseif string_find(p1, "monster_part") ~= nil then
				if db.actor:object(sel_task.target) ~= nil then
					self.task_info[self.active_task_by_type[p1]].status = "completed"
					return true
				end
			elseif string_find(p1, "find_item") ~= nil then
				if db.actor:object(sel_task.target) ~= nil then
					self.task_info[self.active_task_by_type[p1]].status = "completed"
					return true
				end
			end
		end
	end
	return false
end

--' Check to see whether proper TASK
function CRandomTask:task_fail(p1, p2)
  if p2 == 0 then
    local sel_task = self.task_info[self.active_task_by_type[p1]]
     if sel_task == nil then
      --printf("!!!")
      if TB3D_Modders.show_tables == true then show_tables(self.active_task_by_type, nil, "task mgr") end
      --printf("!!!")
      if TB3D_Modders.show_tables == true then show_tables(self.task_info, nil, "task mgr") end
--      if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: WRONG RANDOM TASK ["..utils.to_str(p1).."] ["..utils.to_str(p2).."]") end
      return false
    end
    --' Check that he was alive, has issued the quest.
    local parent = alife():story_object(story_by_parent[sel_task.parent])
    if parent == nil or (parent.alive ~= nil and not parent:alive()) then
      self.task_info[self.active_task_by_type[p1]].status = "failed"
      self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
      return true   
    end
    if sel_task.status == "refused" or sel_task.status == "failed" then
      self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
      return true
    end
    if string_find(p1, "defend_lager") ~= nil then
      if alife():object(sel_task.selected_target).gulag:get_population_comed() == 0 then
        self.task_info[self.active_task_by_type[p1]].status = "failed"
        self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
        return true
      end
    end
  end
  return false
end

--' Zero the variables at the completion or failure of Task
function CRandomTask:task_callback(p1, p2, state)
  if p2 ~= 0 then return end
  if self.active_task_by_type[p1] == nil then return end
  -- Remove the target from the list
  local task_info=self.task_info[self.active_task_by_type[p1]]
  if task_info and task_info.selected_target then
    amk_remove_target_id_from_kill_targets(task_info.selected_target)
  end
  if state == task.completed then
    self.task_info[self.active_task_by_type[p1]].status = "normal"
    --' restoration of the other jobs of this type
    for k,v in pairs(self.task_info) do
      if v.complex_type == self.task_info[self.active_task_by_type[p1]].complex_type then
        v.enabled = true
      end
    end
    self.active_task_by_type[p1] = nil  
  elseif state == task.fail then
    self.task_info[self.active_task_by_type[p1]].status = "normal"
    --' restoration of the other jobs of this type
    for k,v in pairs(self.task_info) do
      if v.complex_type == self.task_info[self.active_task_by_type[p1]].complex_type then
        v.enabled = true
      end
    end
    self.active_task_by_type[p1] = nil  
  end
end

--' Displays a list of available quests
function CRandomTask:action_task_show(npc, actor)
  local parent = self:get_parent(npc) 
	local task_texture = {}
	local task_rect = {}
	if parent then
	  for k,v in pairs(self.task_id_by_parent[parent]) do   
		if self:task_avail(actor, npc, nil, nil, self.task_info[v].init_phrase_id, false) then
		  task_texture, task_rect = get_texture_info("ui_icons_task_"..self.task_info[v].type, "ui_iconsTotal_locations")
		  news_manager.give_talk_message(translate(self.task_info[v].name), task_texture, task_rect,"iconed_trade_info")
		end
	  end
  end
end

--' Check whether the current TASK for extradition
function CRandomTask:task_avail(actor, npc, p1, p2, p3, calculate)
  local task_desc = self.task_info[self.task_id_by_init_phrase_id[p3]]
  --' when calculate == true you should check check_task_props, otherwise just return the value.
  if calculate == "reset" then    
    self.current_parent_type_prior = {}
    return
  elseif calculate == true then
    self:check_task_props(self.task_id_by_init_phrase_id[p3])
    local t = task_desc.enabled and task_desc.enabled_props and task_desc.init_condition == nil
    --' Establish a cutoff in the priorities here.
    if t == true and (self.current_parent_type_prior[task_desc.complex_type] == nil or
       self.current_parent_type_prior[task_desc.complex_type] > task_desc.prior )
    then
      self.current_parent_type_prior[task_desc.complex_type] = task_desc.prior
    end
    return t
  end
--' printf("@@@prior %s -> %s [%s]", task_desc.complex_type, task_desc.prior, tostring(calculate))
--' if TB3D_Modders.show_tables then show_tables(self.current_parent_type_prior, nil, "task mgr") end
  if self.current_parent_type_prior[task_desc.complex_type] ~= nil and
     self.current_parent_type_prior[task_desc.complex_type] < task_desc.prior then
    return false
  end
--' printf("@@@avail %s", tostring(self.task_id_by_init_phrase_id[p3]))
--' printf("@@@enabled %s", tostring(self.task_info[self.task_id_by_init_phrase_id[p3]].enabled))
--' printf("@@@enabled_props %s", tostring(self.task_info[self.task_id_by_init_phrase_id[p3]].enabled_props))
  return task_desc.enabled and task_desc.enabled_props and task_desc.init_condition == nil
end

--' Check the properties of Task
function CRandomTask:check_task_props(task_id)
  --' Check for active jobs of this type of vendor.
  if self.active_task_by_type[self.task_info[task_id].complex_type] ~= nil then
    self.task_info[task_id].enabled_props = false
    return
  end
  --' Validate condition list
  if xr_logic.pick_section_from_condlist(db.actor, db.actor, self.task_info[task_id].condlist) == nil then
    self.task_info[task_id].enabled_props = false
    return
  end
  --' Check Timeout
  if self.task_info[task_id].last_task_time ~= nil and
    game.get_game_time():diffSec(self.task_info[task_id].last_task_time) < self.task_info[task_id].idle_time then
    self.task_info[task_id].enabled_props = false
    return
  end
  --' check to the target
  if self.task_info[task_id].type == "eliminate_lager" then
    if self.task_info[task_id].target_objects == nil then
      self.task_info[task_id].enabled_props = false
      return
    end
	local gulag
    for k,v in pairs(self.task_info[task_id].target_objects) do
      gulag = alife():object(v).gulag
      if gulag:get_population_comed() > 0 then
        self.task_info[task_id].enabled_props = true
        return 
      end
    end
    self.task_info[task_id].enabled_props = false
    return
  elseif self.task_info[task_id].type == "defend_lager" then
    if self.task_info[task_id].target_objects == nil then
      self.task_info[task_id].enabled_props = false
      return
    end
	local defend_object
	local sm_ini = nil
	local defend_target = 0
    for k,v in pairs(self.task_info[task_id].target_objects) do
      defend_object = alife():object(v)
      sm_ini = defend_object:spawn_ini()
      defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
      if xr_gulag.getGulagState(defend_target) == 1 then
        self.task_info[task_id].enabled_props = true
        return
      end
    end
    self.task_info[task_id].enabled_props = false
    return
  elseif self.task_info[task_id].type == "kill_stalker" then
    if self.task_info[task_id].target_objects == nil then
      self.task_info[task_id].enabled_props = false
      return
    end
	local obj
    for k,v in pairs(self.task_info[task_id].target_objects) do
      obj = alife():object(v)
      --' Verifying bug
      if obj ~= nil and obj.alive == nil then 
        --printf("OBJ.ALIVE = nil for task %s", task_id)
        if TB3D_Modders.show_tables == true then show_tables(self.task_info[task_id].target_objects, nil, "task mgr") end
        if TB3D_Modders.use_abort_message == true then TB3D_Services.abort_alert("task mgr: OBJ.NAME = ["..utils.to_str(obj:name()).."]") end      
      end     
      if obj ~= nil and
         obj:alive() == true 
      then
        self.task_info[task_id].enabled_props = true
        return
      else
        table_remove(self.task_info[task_id].target_objects, k)
      end
    end
    self.task_info[task_id].enabled_props = false
    return
  elseif self.task_info[task_id].type == "find_item" then
		if self.task_info[task_id].target_objects == nil or #self.task_info[task_id].target_objects == 0 then
      self.task_info[task_id].enabled_props = false
      return
    end
	local obj, parent
    for k,v in pairs(self.task_info[task_id].target_objects) do
      obj = alife():object(v)
      if obj ~= nil then
        --' To ignore items that are held by the vendors.
        if obj.parent_id ~= nil then
          for kk,vv in pairs(parent_by_story) do
            parent = alife():story_object(kk)
            if parent ~= nil and obj.parent_id == parent.id then
              --' Neglected subject
              self.task_info[task_id].enabled_props = false
              return              
            end
          end
        end
        self.task_info[task_id].enabled_props = true
        return
      end 
      self.task_info[task_id].enabled_props = false
      return
    end
  else
    self.task_info[task_id].enabled_props = true
    return    
  end
end

--' Check whether we can now give  TASK
function CRandomTask:actor_update()
	--if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: Actor update start") end
	for k,v in pairs(self.task_id_self_inited) do
		if self.task_info[v].status == "normal" then
			amk.oau_watchdog=889
			self:check_task_props(v)
			if self.task_info[v].enabled_props == true and
				self.task_info[v].enabled == true and
				xr_logic.pick_section_from_condlist(db.actor, db.actor, self.task_info[v].init_condition) ~= nil then
				--amk.oau_watchdog=888
				--' You want to automatically give the quest
				if TB3D_Modders.use_task_message == true then TB3D_Services.packet_alert("TASK MGR: actor update self init task ["..utils.to_str(v).."]") end
				self:action_give_task(db.actor, nil, nil, self.task_info[v].yes_phrase_id)
			end
		end
	end
	--amk.oau_watchdog=887
	--if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: Actor update end") end
end

--' Checks whether the current TASK outstanding player
function CRandomTask:active_task(actor, npc, p1, p2, p3)
  return self.task_info[self.task_id_by_init_phrase_id[p3]].status == "selected" or
          self.task_info[self.task_id_by_init_phrase_id[p3]].status == "completed"
end

function CRandomTask:make_task_failed(task_id)
  if self.task_info and self.task_info[task_id] then
    self.task_info[task_id].status="failed"
  end
end

-- Checks for quest items
function CRandomTask:completed_task(actor, npc, p1, p2, p3)
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR:Checking quest items p1["..utils.to_str(p1).."] p2["..utils.to_str(p2).."] p3["..utils.to_str(p3).."]") end
	local can_finish = false
	if p3 then --return false end
		local tid=self.task_id_by_desc_phrase_id[p2]
		if tid then --return false end
			local task_desc=self.task_info[tid]
			if task_desc.status == "completed" then --return false end
			  can_finish = true
			elseif task_desc.type == "artefact" then
				if db.actor:object(task_desc.target) ~= nil then
				  can_finish = true
				end
			elseif task_desc.type == "monster_part" then
				if db.actor:object(task_desc.target) ~= nil then
				  can_finish = true
				end
			elseif task_desc.type == "find_item" then
				if db.actor:object(task_desc.target) ~= nil then
				  can_finish = true
				end
			end
		end
	end
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: can finish =["..utils.to_str(can_finish).."]") end
	return can_finish
end

--' Actor creates a dialogue, which will be issued to the job.
function CRandomTask:init_task_dialog(dlg, parent)
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: init task dialog start") end
	local phr = dlg:AddPhrase("tm_seek_new_job","0","",-10000)
	local phrase_script = phr:GetPhraseScript()
	phr = dlg:AddPhrase("tm_"..parent.."_list_job","1","0",-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.action_task_show")
	phrase_script:AddPrecondition("task_manager.precondition_vendor_can_task")
	phr = dlg:AddPhrase("tm_"..parent.."_has_no_job","2","0",-10000)
  phrase_script = phr:GetPhraseScript()
  phrase_script:AddPrecondition("task_manager.precondition_vendor_cannot_task")
  for k,v in pairs(self.task_id_by_parent[parent]) do
		phr = dlg:AddPhrase(self.task_info[v].name, tostring(self.task_info[v].init_phrase_id), "1", -10000)		
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddPrecondition("task_manager.precondition_task_avail")
		phr = dlg:AddPhrase(self.task_info[v].text, tostring(self.task_info[v].desc_phrase_id), tostring(self.task_info[v].init_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.show_reward")
		phr = dlg:AddPhrase("tm_seek_job_yes", tostring(self.task_info[v].yes_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_give_task")
		phr = dlg:AddPhrase("tm_seek_job_no", tostring(self.task_info[v].no_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
	end
	dlg:AddPhrase("tm_seek_job_abandon","3","1",-10000)
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: init task dialog done") end
end

--' Function, which will be issued merchandise rewards for completed quests
function CRandomTask:task_reward(npc, actor, p1, p2)
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: Rewarding p1["..utils.to_str(p1).."] p2["..utils.to_str(p2).."]") end
  local parent = self:get_parent(npc) 
  local v=self.task_id_by_completed_phrase_id[p2]
--  TB3D_Services.info_alert("Rewarding ")
--  for k,v in pairs(self.active_task_by_type) do 
  if true then
    local task_desc = self.task_info[v]
    if task_desc.status == "completed" and task_desc.parent == parent then
      --' We take away the player's quest item.
      local can_finish = true
      if task_desc.type == "artefact" then
        if db.actor:object(task_desc.target) == nil then
          can_finish = false
        else
          dialogs.relocate_item_section(npc, task_desc.target, "out")
        end
      elseif task_desc.type == "monster_part" then
        if db.actor:object(task_desc.target) == nil then
          can_finish = false
        else
          dialogs.relocate_item_section(npc, task_desc.target, "out")
        end
      elseif task_desc.type == "find_item" then
        if db.actor:object(task_desc.target) == nil then
          can_finish = false
        else
          dialogs.relocate_item_section(npc, task_desc.target, "out")
        end
      end
      if can_finish == true then
        self.task_info[v].status = "rewarded"
        if task_desc.reward_money ~= nil then
          dialogs.relocate_money(npc, task_desc.reward_money, "in")
        end
        if task_desc.reward_item ~= nil then
          for kk,vv in pairs(task_desc.reward_item) do
            dialogs.relocate_item_section(npc, vv, "in")
          end
        end
        if task_desc.reward_reputation ~= nil then
			TB3D_Services.change_reputation(db.actor, task_desc.reward_reputation)
        end
        if task_desc.reward_relation ~= nil then
          for kk,vv in pairs(task_desc.reward_relation) do
            relation_registry.change_community_goodwill (kk, db.actor:id(), tonumber(vv))
          end
        end
        --if task_desc.reward_rank ~= nil then
          actor_stats.add_points("quests", task_desc.name, 1, task_desc.reward_rank)
			TB3D_Services.change_rank(db.actor, task_desc.reward_rank)
          --db.actor:set_character_rank(db.actor:character_rank() + task_desc.reward_rank)
        --end
      end
    end 
  end
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: task reward done") end
end

--' Function, which will be issued merchandise rewards for completed quests storilaynovye
function CRandomTask:task_reward_storyline(task)
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: task reward storyline start") end
  local task_desc = self.task_info[task:get_id()]
  if task_desc == nil or task_desc.type ~= "storyline" then
    return
  end

  if task_desc.reward_reputation ~= nil then
			TB3D_Services.change_reputation(db.actor, task_desc.reward_reputation)
  end

  if task_desc.reward_relation ~= nil then
    for kk,vv in pairs(task_desc.reward_relation) do
      relation_registry.change_community_goodwill (kk, db.actor:id(), tonumber(vv))
    end
  end

  --if task_desc.reward_rank ~= nil then
    actor_stats.add_points("quests", task_desc.name, 1, task_desc.reward_rank)
			TB3D_Services.change_rank(db.actor, task_desc.reward_rank)
    --db.actor:set_character_rank(db.actor:character_rank() + task_desc.reward_rank)
 -- end
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: task reward storyline done") end
end

--' It creates a dialogue actor, who will take the job
function CRandomTask:init_reward_dialog(dlg, parent)
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: init reward dialog start") end
	local phr = dlg:AddPhrase("tm_reward_job","0","",-10000)
	local phrase_script = phr:GetPhraseScript()
	local phrcnt
	local prid, cid
	local first
--[[
	phr = dlg:AddPhrase("tm_"..parent.."_job_complete", "1", "0", -10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.action_task_reward")
	phrase_script:AddPrecondition("task_manager.precondition_have_completed_job")
]]--
	phr = dlg:AddPhrase("tm_"..parent.."_job_ask", "2", "0", -10000)
	phrase_script = phr:GetPhraseScript()
	--phrase_script:AddPrecondition("task_manager.precondition_dont_have_completed_job")
	-- The list of possible quests trader.
	for k,v in pairs(self.task_id_by_parent[parent]) do
		--TB3D_Services.packet_alert("task mgr: init rwd dialog["..utils.to_str(self.task_info[v].name).."]["..utils.to_str(self.task_info[v].init_phrase_id).."]")
		phr = dlg:AddPhrase(self.task_info[v].name, tostring(self.task_info[v].init_phrase_id), "2", -10000)
		phrase_script = phr:GetPhraseScript()   
		phrase_script:AddPrecondition("task_manager.precondition_active_task")
		phr = dlg:AddPhrase("tm_"..parent.."_job_what", tostring(self.task_info[v].desc_phrase_id), tostring(self.task_info[v].init_phrase_id), -10000)
		phr = dlg:AddPhrase("tm_job_refuse", tostring(self.task_info[v].yes_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_refuse_task")
		phrase_script:AddPrecondition("task_manager.precondition_notcompleted_task")
		phr = dlg:AddPhrase("tm_job_nothing", tostring(self.task_info[v].no_phrase_id), tostring(self.task_info[v].desc_phrase_id),-10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddPrecondition("task_manager.precondition_notcompleted_task")
		phr = dlg:AddPhrase("tm_job_completed", tostring(self.task_info[v].completed_phrase_id), tostring(self.task_info[v].desc_phrase_id),-10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_task_reward")
		phrase_script:AddPrecondition("task_manager.precondition_completed_task")
		if self.task_info[v].reward_info then
			phrcnt=#self.task_info[v].reward_info_dialog
			if phrcnt==0 then
				-- phrase_script:AddGiveInfo(self.task_info[v].reward_info_portion)
				for i=1,#self.task_info[v].reward_info_portion do
					local info_portion = self.task_info[v].reward_info_portion[i]
					if info_portion ~= nil and not has_alife_info(info_portion) then
						if TB3D_Modders.use_task_message == true then TB3D_Services.packet_alert("task mgr: init rwd dialog give info["..utils.to_str(info_portion).."]") end
						phrase_script:AddGiveInfo(info_portion)
					end
				end
				phrase_script:AddAction("amk_dialogs.info_received")
			else
				-- Add the phrase. to the case of infoportsii. Otherwise, go forth.
				phr = dlg:AddPhrase("...",self:gen_phrase_id(),tostring(self.task_info[v].completed_phrase_id),-10000)
				phrase_script = phr:GetPhraseScript()
				--phrase_script:AddHasInfo(self.task_info[v].reward_info_portion)        
				for i=1,#self.task_info[v].reward_info_portion do
					phrase_script:AddHasInfo(self.task_info[v].reward_info_portion[i])
				end
				prid = nil
				prid=tostring(self.task_info[v].completed_phrase_id)
				first=true
				-- Adding dialogue
				for i,p in ipairs(self.task_info[v].reward_info_dialog) do
					cid=self:gen_phrase_id()
					phr=dlg:AddPhrase(p,cid,prid,-10000)
					prid=cid
					if first then
						first=false
						phrase_script = phr:GetPhraseScript()
						-- phrase_script:AddGiveInfo(self.task_info[v].reward_info_portion)
						for i=1,#self.task_info[v].reward_info_portion do
							phrase_script:AddGiveInfo(self.task_info[v].reward_info_portion[i])
							phrase_script:AddDontHasInfo(self.task_info[v].reward_info_portion[i])        
						end
						phrase_script:AddAction("amk_dialogs.info_received")
					end
				end
			end
		end
	end
	if TB3D_Modders.use_task_message == true then TB3D_Services.packet_alert("task mgr: init rwd dialog["..utils.to_str(phrcnt).."]["..utils.to_str(prid).."]["..utils.to_str(cid).."] done") end
end

local stalker_count, smart_count, defend_count, item_count = 0,0,0,0
function show_counts()
	TB3D_Services.packet_alert("TB3D: tasks: stalker loaded["..utils.to_str(stalker_count).."]")
	TB3D_Services.packet_alert("TB3D: tasks: items loaded["..utils.to_str(item_count).."]")
	TB3D_Services.packet_alert("TB3D: tasks: defend loaded["..utils.to_str(defend_count).."]")
	TB3D_Services.packet_alert("TB3D: tasks: smarts loaded["..utils.to_str(smart_count).."]")
end

--' Registration for the purposes of quests.   --!!!!TB3D
function CRandomTask:register_target(obj)
if obj then
	local rstring = "NONE"
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: register target NAME["..utils.to_str(obj:name()).."] sect["..utils.to_str(get_section(obj)).."]") end
	if IAmAStalker[obj:clsid()] then
		rstring = "STALKER"
		--' Probably recorded goal for the quest to kill the stalker "
		for k,v in pairs(self.task_id_by_type["kill_stalker"]) do 
			if obj.alive ~= nil and obj:alive() == true and obj:profile_name() == self.task_info[v].target then
				if self.task_info[v].target_objects == nil then self.task_info[v].target_objects = {} end	--create first entry
				if TB3D_Modders.use_task_message == true then TB3D_Services.packet_alert("TASK MGR: kill stalker ["..utils.to_str(v).."]") end
				self.task_info[v].target_objects[#self.task_info[v].target_objects+1] = obj.id
				stalker_count = stalker_count + 1
				return	--TB3D verified works 109924
			end
		end
	elseif obj:clsid() == clsid.smart_terrain then
		rstring = "SMART TERRAIN"
		--' Probably recorded goal for the quest "to make camp
		for k,v in pairs(self.task_id_by_type["eliminate_lager"]) do
			if obj:name() == self.task_info[v].target then
				if self.task_info[v].target_objects == nil then self.task_info[v].target_objects = {} end	--create first entry
				if TB3D_Modders.use_task_message == true then TB3D_Services.packet_alert("TASK MGR: eliminate target ["..utils.to_str(v).."]") end
				self.task_info[v].target_objects[#self.task_info[v].target_objects+1] = obj.id
				smart_count = smart_count + 1
				return	--TB3D verified works 109924
			end
		end
		--' Or register for the purpose of the quest "to protect the camp"
		for k,v in pairs(self.task_id_by_type["defend_lager"]) do
			if obj:name() == self.task_info[v].target then
				--' Verify that the date specified in the custom from anyone to defend
				--local sm_ini = obj:spawn_ini()
				--local defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
				if self.task_info[v].target_objects == nil then self.task_info[v].target_objects = {} end	--create first entry
				if TB3D_Modders.use_task_message == true then TB3D_Services.packet_alert("TASK MGR: defend target ["..utils.to_str(v).."]") end
				self.task_info[v].target_objects[#self.task_info[v].target_objects+1] = obj.id
				defend_count = defend_count + 1
				return	--TB3D verified works 109924
			end
		end
	else
		rstring = "ITEM"
		--' Probably recorded goal for the quest "to find the object"
		for k,v in pairs(self.task_id_by_type["find_item"]) do
		--TB3D_Services.packet_alert("TASK MGR: find item =["..utils.to_str(self.task_info[v].target).."]")
			if get_section(obj) == self.task_info[v].target then
				if self.task_info[v].target_objects == nil then	self.task_info[v].target_objects = {} end	--create first entry
				if TB3D_Modders.use_task_message == true then TB3D_Services.packet_alert("TASK MGR: find item ["..utils.to_str(v).."]") end
				self.task_info[v].target_objects[#self.task_info[v].target_objects+1] = obj.id
				item_count = item_count + 1
				return	--TB3D verified works 109924
			end
		end
	end
	if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: register["..utils.to_str(rstring).."]") end
	rstring = ""
	end
end

--' OTRegistratsiya objectives for quests.
function CRandomTask:unregister_target(obj)
  if IAmAStalker[obj:clsid()] then
    --' Probably recorded goal for the quest to kill the stalker "
    for k,v in pairs(self.task_id_by_type["kill_stalker"]) do 
      if self.task_info[v].target_objects ~= nil then
        for kk,vv in pairs(self.task_info[v].target_objects) do
          if vv == obj.id then
            if vv then table_remove(self.task_info[v].target_objects, vv) end
			break	--TB3D verified works 109924
          end
        end     
      end
    end
  elseif obj:clsid() == clsid.smart_terrain then
	--nothing
  else
    --' Probably recorded goal for the quest "to find the object"
    for k,v in pairs(self.task_id_by_type["find_item"]) do
      if self.task_info[v].target_objects ~= nil then
        for kk,vv in pairs(self.task_info[v].target_objects) do
          if vv == obj.id then
            if vv then table_remove(self.task_info[v].target_objects, vv) end
			break	--TB3D verified works 109924
          end
        end     
      end
    end
  end
end

function CRandomTask:stats(obj)
	if TB3D_Modders.show_tables == true then
		for k,v in pairs(self.task_info) do
			if v.init_condition ~= nil then
				show_tables(v.init_condition, nil, "task mgr")
			end
		end
    end
end

function get_random_task()
  if random_task == nil then
    random_task = CRandomTask()
  end
  return random_task
end


function init_trader_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "trader")
end
function init_barman_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "barman")
end
function init_ecolog_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "ecolog")
end
function init_dolg_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "dolg")
end
function init_freedom_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "freedom")
end


function init_shustriy_task_dialog(dlg)
	--if TB3D_Services.is_collector() == false then
		get_random_task():init_task_dialog(dlg, "shustriy")
	--end
end
function init_lisiy_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "lisiy")
end
function init_hunter_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "hunter")
end
function init_drunk_dolg_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "drunk_dolg")
end
function init_petrenko_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "petrenko")
end
function init_wolf_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "wolf")
end
function init_zastava_commander_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "zastava_commander")
end
function init_mercenary_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "mercenary")
end

function init_green_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "green")
end



function init_trader_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "trader")
end
function init_barman_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "barman")
end
function init_ecolog_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "ecolog")
end
function init_dolg_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "dolg")
end
function init_freedom_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "freedom")
end



function init_shustriy_reward_dialog(dlg)
	--if TB3D_Services.is_collector() == false then
		get_random_task():init_reward_dialog(dlg, "shustriy")
	--end
end
function init_lisiy_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "lisiy")
end
function init_hunter_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "hunter")
end
function init_drunk_dolg_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "drunk_dolg")
end
function init_petrenko_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "petrenko")
end
function init_wolf_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "wolf")
end
function init_zastava_commander_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "zastava_commander")
end
function init_mercenary_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "mercenary")
end

function init_green_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "green")
end


function has_active_vendor_task(actor, npc)
  return get_random_task():active_parent_task(actor, npc)
end
function precondition_task_avail(actor, npc, p1, p2, p3)
  return get_random_task():task_avail(actor, npc, p1, p2, p3, false)
end
function precondition_active_task(actor, npc, p1, p2, p3)
  return get_random_task():active_task(actor, npc, p1, p2, p3)
end
function precondition_completed_task(actor, npc, p1, p2, p3)
  return get_random_task():completed_task(actor, npc, p1, p2, p3)
end
function precondition_notcompleted_task(actor, npc, p1, p2, p3)
  return not get_random_task():completed_task(actor, npc, p1, p2, p3)
end

function precondition_vendor_can_task(npc, actor, p1, p2, p3)
  return get_random_task():parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_vendor_cannot_task(npc, actor, p1, p2, p3)
  return not get_random_task():parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_have_completed_job(npc, actor, p1, p2, p3)
  return get_random_task():have_completed_job(actor, npc)
end
function precondition_dont_have_completed_job(npc, actor, p1, p2, p3)
  return not get_random_task():have_completed_job(actor, npc)
end

function action_task_show(npc, actor)
  get_random_task():action_task_show(npc, actor)
end
function action_give_task(actor, npc, p1, p2)
  --if TB3D_Services.is_collector() == true and not db.actor:has_info("tb3d_collector_done") then return end
  get_random_task():action_give_task(actor, npc, p1, p2)
end
function action_refuse_task(npc, actor, p1, p2)
  get_random_task():action_refuse_task(npc, actor, p1, p2)
end
function action_task_reward(actor, npc, p1, p2)
  get_random_task():task_reward(npc, actor, p1, p2)
end
function reward_by_task(task) 
  get_random_task():task_reward_storyline(task)
end

function task_complete(p1, p2)
  return get_random_task():task_complete(p1, p2)
end
function task_fail(p1, p2)
  return get_random_task():task_fail(p1, p2)
end
function task_callback(p1, p2, state)
  return get_random_task():task_callback(p1, p2, state)
end

function actor_update()
  get_random_task():actor_update()
end

function save(p)
  get_random_task():save(p)
end
function load(p)
  get_random_task():load(p)
end
function clear_task_manager()		--called from _g.script
  random_task  = nil
end

function amk_add_target_id_to_kill_targets(id,dialog,task_id)
  local targets=amk.unpack_array_from_string(amk.load_variable("kill_targets",""))
  targets[#targets+1] = {id=id,dialog=dialog,task_id=task_id}
  amk.save_variable("kill_targets",amk.pack_array_to_string(targets))
end

function amk_remove_target_id_from_kill_targets(id)
  local targets=amk.unpack_array_from_string(amk.load_variable("kill_targets",""))
  for n,v in pairs(targets) do
    if v.id==id then
      table_remove(targets,n)
      break
    end
  end
  amk.save_variable("kill_targets",amk.pack_array_to_string(targets))
end

function amk_kill_targets()
  return amk.unpack_array_from_string(amk.load_variable("kill_targets",""))  
end

function make_task_failed(task_id)
  get_random_task():make_task_failed(task_id)  
end

function show_reward(actor,npc,p1,p2)
  if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: show reward") end
	local reward_text, reward_money, task_details
	if random_task == nil then
		random_task = task_manager.CRandomTask()
	end
	task_details = random_task.task_info[random_task.task_id_by_init_phrase_id[p2-1]]
	if task_details == nil then return end
	reward_text = format_reward_text(task_details.reward_item)
	reward_money = task_details.reward_money
	local task_texture, task_rect = get_texture_info("ui_iconsTotal_find_item")
	if reward_text ~= nil and reward_text ~= "" then
		news_manager.give_talk_message("For that I'll give you:", "ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item")
		news_manager.give_talk_message(reward_text, task_texture, task_rect,"iconed_trade_info")
	end
	if reward_money ~= nil then 
		task_texture, task_rect = get_texture_info("ui_iconsTotal_found_money")
		if task_details.need_return and reward_text == "" then
			news_manager.give_talk_message(reward_money .. " RU (" .. translate("return_for_reward") .. ")", task_texture, task_rect, "iconed_trade_info")
		else
			news_manager.give_talk_message(reward_money .. " RU", task_texture, task_rect,"iconed_trade_info")
		end
	end
  if TB3D_Modders.use_task_message == true then TB3D_Services.info_alert("TASK MGR: show reward done") end
end

function format_reward_text(reward_list)
	local i,v, ii, vv
	local rwd = {}
	local reward_text = ""
	if reward_list == nil then return "" end
	for i,v in pairs(reward_list) do
		if rwd[v] == nil then
			rwd[v] = 1
		else
			rwd[v] = rwd[v] + 1
		end
	end
	for i,v in pairs(rwd) do
		if v == 1 then
			reward_text = reward_text .. translate(news_manager.get_inv_name(i)) .. ", "
		else
			reward_text = reward_text .. string.format("%s",v) .. "x " .. translate(news_manager.get_inv_name(i)) .. ", "
		end
	end
	if string_len(reward_text) >=2 then
		reward_text = string_sub (reward_text, 1, string_len(reward_text)-2)
	end
	return reward_text
end
