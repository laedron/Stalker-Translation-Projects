--TB3D 1.1.0.0.1.0  optimized gulag checks, heli see actor fix, killed by actor fix for atp, val_sacrifice sids, killed by actor,
-- killed by actor eagle, db storage, gulag_population_ge, exclusives, killed_by_eagle, killed_by_actor, esc2_st_fabric, killed by actor,
-- after wish granter, debug, killed_by_actor, dist to actor defaults
function my_ver() return "1.1.0.0.1.0" end
-- Each function in this file is used as a condition xr_logic: {= function "function"}
-- If the function needs to pass parameters, then: {= function (param1: param2 :...)! Function (param1: param2 :...)}
-- Format: function f (actor, npc). In the case of passing parameters: function f (actor, npc, p).
-- Implementation details should be placed in the file xr_conditions_impl.script, but not in the file.

-- ----------------------------------------------------------------------------------------------------
-- General functions
-- ----------------------------------------------------------------------------------------------------
-- whether we see more "black screen" or not?
function black_screen(actor, npc)
	return device().precache_frame > 1
end

-- 
function is_actor_sleeping(actor, npc)
    return db.actor:is_actor_sleeping()
end

-- check that the actor is alive
function actor_alive(actor, npc)
    if db.actor and db.actor:alive() then
	    return true
	end
	return false
end

-- check that the actor is dead
function actor_dead(actor, npc)
    if db.actor and not db.actor:alive() then
	    return true
	end
	return false
end

function see_npc(actor, npc, p)
    local npc1 = level_object_by_sid(p[1])
    if npc and npc1 then
        --printf("cond <see_npc>: [%s]->[%s]", npc:name(), npc1:name())
        return npc:see(npc1)
    else
        return false
    end
end

function is_wounded(actor, npc)
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag["..utils.to_str(npc:name()).."] is wounded["..utils.to_str(xr_wounded.is_wounded(npc)).."]") end
	return xr_wounded.is_wounded(npc)
end

function dist_to_actor_le(actor, npc, p)
    local d = p[1]
	if d then
		return npc:position():distance_to_sqr(actor:position()) <= d * d
	end
	return false		--110010, default to not being close
end

function dist_to_actor_ge(actor, npc, p)
    local d = p[1]
	if d then
		return npc:position():distance_to_sqr(actor:position()) >= d * d
	end
	return true			--110010, default to being too far
end

-- verifying that the distance to the object <= given
-- parameters: [sid,dist]
function distance_to_obj_le(actor, npc, p)
    local npc1 = level_object_by_sid(p[1])
    if npc1 then
        local res = npc:position():distance_to_sqr(npc1:position()) <= p[2]*p[2]
        if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag["..utils.to_str(npc:name()).."] distance_to_obj_le["..utils.to_str(res).."]") end
	    return res
	end
	return false
end

-- verifying that the distance to the object = given
-- parameters: [sid,dist]
function distance_to_obj_ge(actor, npc, p)
    local npc1 = level_object_by_sid(p[1])
    if npc1 then
        local res = npc:position():distance_to_sqr(npc1:position()) >= p[2]*p[2]
        if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag["..utils.to_str(npc:name()).."] distance_to_obj_ge["..utils.to_str(res).."]") end
	    return res
	end
	return true	--110010, false
end

-- verifying that the npc is in a given area
-- !!! Called only from SPACE RESTRICTOR !!!
-- parameters: [sid1:sid2:...]
-- !!! INCORRECT WORKS FOR OBJECTS IN offline'e !!!
-- !!! FOR USE OF WARRANTIES one_obj_in_zone !!!
function obj_in_zone(actor, zone, p)		--TB3D  10992, krug - rostok
	for i, v in pairs(p) do
	    npc1 = level_object_by_sid(v)
        if npc1 and zone:inside(npc1:position()) then
			if TB3D_Modders.use_conditions_message == true then
				TB3D_Services.packet_alert("xr cond: obj in zone[true] npc["..utils.to_str(npc1:name()).."]")
			end
            return true
        end
    end
	if TB3D_Modders.use_conditions_message == true then
		TB3D_Services.packet_alert("xr cond: obj in zone[false] npc["..utils.to_str(npc1:name()).."]")
	end
    return false
end

-- parameters: [sid:def*] def=true|false
-- * Parameter is optional
function one_obj_in_zone(actor, zone, p)
    --local def_offline = (p[2] ~= "false") -- default (true) result if npc in offline
	local obj1 = level_object_by_sid(p[1])
    if obj1 then -- npc is online
        return zone:inside(obj1:position())
    else -- npc is offline
        return (p[2] ~= "false") -- default (true) result if npc in offline
    end
end

function actor_in_zone(actor, npc, p)
	local zone = db.zone_by_name[p[1]]
	if zone == nil then return false end			--110010, default not in zone
	return utils.npc_in_zone(db.actor, zone)
end
function actor_out_zone(actor, npc, p)
	local zone = db.zone_by_name[p[1]]
	if zone == nil then	return true end				--110010, default is not in zone
	return not utils.npc_in_zone(db.actor, zone)	--110010, db.zone_by_name[p[1]])
end

-- true, if health npc <= setpoint
-- false otherwise
function health_le(actor, npc, p)
    return p[1] and npc.health < p[1]
end

-- true, If the helicopter health <= setpoint
-- false otherwise
function heli_health_le(actor, obj, p)
    return p[1] and obj:get_helicopter():GetfHealth() < p[1]
end

-- sees a helicopter npc (on story id)
function heli_see_npc(actor, obj, p)
	if p[1] then
		local o = level_object_by_sid( p[1] )
		return o ~= nil and obj:get_helicopter():isVisible( o )
	else
		return false
	end
end

-- Check for membership in an enemy to one of the groups
-- (You can specify multiple colon)
function enemy_group(actor, npc, p)
	local g = db.storage[npc:id()].enemy:group()
	for i, v in pairs(p) do
		if v == g then
			if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: enemy group for["..utils.to_str(npc:name()).."] is["..utils.to_str(v).."]") end
			return true
		end
	end
	return false
end

function enemy_gulag(actor, npc, p)
	local enemy = db.storage[npc:id()].enemy
	if enemy and enemy:alive() and enemy:id() ~= actor:id() then
        local g = xr_gulag.get_npc_gulag(enemy)
        if g ~= nil then
            local n = g.name
            for i, v in pairs(p) do
                if n == v then
					if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: enemy gulag["..utils.to_str(npc:name()).."] [true]") end
                    return true
                end
            end
        end
    end
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: enemy gulag["..utils.to_str(npc:name()).."] [false]") end
    return false
end

function gulag_state(actor, npc, p)
	if xr_gulag.getGulagState(p[1]) == p[2] then
		return true
	end
	return false
end

function npc_community(actor, npc, p)
	if p[1] == nil then
		if TB3D_Modders.use_conditions_message == true then TB3D_Services.abort_alert("xr cond: Wrong number of params in npc_community["..utils.to_str(npc:name()).."]") end
	end
	if npc:character_community() == p[1] then
		return true
	end
	return false
end

function npc_rank(actor, npc, p)
	if p[1] == nil then
		if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: Wrong number of params in npc_rank["..utils.to_str(npc:name()).."]") end
	end
	if ranks.get_obj_rank_name(npc) == p[1] then
		return true
	end
	return false
end

function npc_profile(actor, npc, p)
	if p[1] == nil then
		if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: Wrong number of params in npc_profile["..utils.to_str(npc:name()).."]") end
	end
	if npc:profile_name() == p[1] then
		return true
	end
	return false
end


-- Verifying that the blow was struck by one of the npc mentioned in the list.
-- Parameters of this story_id characters. You can specify multiple story_id.
function hitted_by(actor, npc, p)
	local npc1
	local t = db.storage[npc:id()].hit
	if t then
		for i, v in pairs(p) do
			npc1 = level_object_by_sid(v)
			if npc1 and t.who == npc1:id() then
				--printf("_bp: hitted_by(%d)", v)
				return true
			end
		end
	end
	return false
end

-- Verify that the best weapon of the character - a gun
function best_pistol(actor, npc)
	local pistol = npc:item_in_slot(1)
	if pistol ~= nil then
		TB3D_Services.packet_alert("xr conditions: best pistol[true] for["..npc:name().."]")
		return true
	else
		TB3D_Services.packet_alert("xr conditions: best pistol[false] for["..npc:name().."]")
		return false
	end
--[[
	local wpn = npc:best_weapon()
	if wpn == nil then
		return false
	end
	wpn = get_clsid(wpn)
	if wpn == nil then
		return false
	end
	if wpn == clsid.wpn_hpsa then return true
    elseif wpn == clsid.wpn_hpsa then return true
    elseif wpn == clsid.wpn_pm then return true
    elseif wpn == clsid.wpn_fort then return true
    elseif wpn == clsid.wpn_walther then return true
    elseif wpn == clsid.wpn_usp45 then return true
    else return false end
]]
end

-- Verifying that the character was killed by someone from npc mentioned in the list.
-- Options are story_id characters. You can specify multiple story_id.
function killed_by(actor, npc, p)
	local npc1
	local t = db.storage[npc:id()].death
	if t then
		for i, v in pairs(p) do
			npc1 = level_object_by_sid(v)
			if npc1 and t.killer == npc1:id() then
				--printf("_bp: killed_by(%d)", v)
				return true
			end
		end
	end
	return false
end

-- test (on story_id) whether all testable stalkers live
-- TODO: rectify the situation, when given the wrong result for objects that are
--       not yet prospavnitsya.
function is_alive_all(actor, npc, p)
	local npc1
	for i, v in pairs(p) do
		npc1 = level_object_by_sid(v)
		if npc1 and not npc1:alive() then
			return false
		end
	end
	return true
end

-- test (on story_id) the fact that though we do have a verifiable stalkers live
-- TODO: rectify the situation, when given the wrong result for objects that are
--       not yet prospavnitsya.
function is_alive_one(actor, npc, p)
	local npc1
	for i, v in pairs(p) do
		npc1 = level_object_by_sid(v)
		if npc1 and npc1:alive() then
			if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: is alive one: true") end
			return true
		end
	end
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: is alive one: false") end
	return false
end

-- test (on story_id) that proveryaemyq npc alive
-- TODO: rectify the situation, when given the wrong result for objects that are
--       not yet spawned.
function is_alive(actor, npc, p)
	local npc1
	local result = false
	npc1 = level_object_by_sid(p[1])
	if npc1 then
		--if TB3D_Services.is_collector() and p[1] == 32 then						--109955 for testing: keeps guards from attacking
			--result = true
		--else
			if npc1.alive and npc1:alive() == true then result = true end
		--end
		--if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: is alive["..npc1:name().."]["..utils.to_str(result).."]") end
	end
	return result
end

-- test (on story_id) whether all testable stalkers are dead
-- TODO: rectify the situation, when given the wrong result for objects that are
--       not yet spawned.
function is_dead_all(actor, npc, p)
	local npc1
	for i, v in pairs(p) do
		npc1 = level_object_by_sid(v)
		if npc1 then
			if npc1:alive() then
				if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("all dead: false") end
				return false
			else
				if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("all dead: true") end
			end
		end
	end
	return true
end

-- test (on story_id) that at least one verifiable stalkers is dead
-- TODO: rectify the situation, when given the wrong result for objects that are
--       not yet prospavnitsya.
function is_dead_one(actor, npc, p)
	local npc1
	for i, v in pairs(p) do
		npc1 = level_object_by_sid(v)
		if not npc1 or not npc1:alive() then
			--printf("_bp: is_dead_one(%d) = true", v)
			return true
		end
	end
	return false
end

-- test (on story_id) that at least one verifiable stalkers is dead
-- TODO: rectify the situation, when given the wrong result for objects that are
--       not yet prospavnitsya.
function is_dead(actor, npc, p)
	local npc1
	npc1 = level_object_by_sid(p[1])
	if npc1 then
		if npc1.alive and npc1.alive() == true then return false end
	end
	return true
end

-- test (on story_id) that our enemy has at least which is one of a list
function check_fighting(actor, npc, p)
	local enemy = db.storage[npc:id()].enemy
	if enemy and enemy:alive() then
	    local sid = enemy:story_id()
	    for i, v in pairs(p) do
		    if type(v) == 'number' and sid == v then
				if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag["..utils.to_str(npc:name()).."] fighting[true]") end
			    return true		   
		    end
	    end
	end
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag["..utils.to_str(npc:name()).."] fighting[false]") end
	return false
end

function val_nap1_check_fighting(actor, npc, p)
	local enemy, npc1
	for i, v in pairs(p) do
	    npc1 = level_object_by_sid(v)
	    if npc1 then
	        enemy = npc1:best_enemy()
		    if enemy and (enemy:id() == npc:id() or enemy:id() == actor:id()) then
			    return true
		    end
		end
	end
	return false
end

-- true, if the gulag of the same name (or the story id) not exist or has no one
function gulag_empty(actor, npc, p)
	local reslt = true						--default to true incase no data
	if p[1] then
		reslt = xr_gulag.getGulagPopulationComed( p[1] ) == 0
	end
	if TB3D_Modders.use_conditions_message == true then 
		TB3D_Services.packet_alert("xr_cond: gulag empty["..utils.to_str(reslt).."]["..utils.to_str(p[1]).."]["..utils.to_str(xr_gulag.getGulagPopulationComed( p[1] )).."]")
	end
	return reslt
end

-- true, if in that gulag fewer people than usual.
function gulag_population_le(actor, npc, p)
	local reslt = true						--default to true incase no data
	if p[1] and p[2] then
		reslt = xr_gulag.getGulagPopulation( p[1] ) <= p[2]
	end
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag["..utils.to_str(npc:name()).."] population le["..utils.to_str(reslt).."]["..utils.to_str(p[1]).."]["..utils.to_str(p[2]).."]") end
	return reslt
end

-- true, if in that gulag people more than necessary.
function gulag_population_ge(actor, npc, p)
	--if string.find(p[1], "val_smart_monster_lair") then return true end
	local reslt = false
	if p[1] and p[2] then
		if xr_gulag.getGulagPopulation( p[1] ) >= p[2] then reslt = true end		--defaults to false if missing data
	end
	if TB3D_Modders.use_conditions_message == true then 
		TB3D_Services.packet_alert("xr cond: gulag["..utils.to_str(npc:name()).."] population ge["..utils.to_str(reslt).."]["..utils.to_str(p[1]).."]["..utils.to_str(p[2]).."]") 
	end
	return reslt
end

-- true, if in that gulag came less people than necessary.
function gulag_population_comed_le(actor, npc, p)
	local reslt = true						--default to true incase no data
	if p[1] and p[2] then
		reslt = xr_gulag.getGulagPopulationComed( p[1] ) <= p[2]
	end
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag["..utils.to_str(npc:name()).."] population comed le["..utils.to_str(reslt).."]["..utils.to_str(p[1]).."]["..utils.to_str(p[2]).."]") end
	return reslt
end

-- true, if in that gulag came to the people more than necessary.
function gulag_population_comed_ge(actor, npc, p)
	--if p[1] == "esc2_most" then return false end
	local reslt
	if p[1] and p[2] then
		reslt = xr_gulag.getGulagPopulationComed( p[1] ) >= p[2]		--defaults to false if missing data
	else
		reslt = false --true
	end
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag["..utils.to_str(npc:name()).."] population comed ge["..utils.to_str(reslt).."]["..utils.to_str(p[1]).."]["..utils.to_str(p[2]).."]") end
	return reslt
end

-- returns the number of dangerous characters in the gulag (alive and not injured).
---called in xr_conditions only
function gulag_population_active(actor, npc, p)
	 local gulag = xr_gulag.get_gulag_by_name( p[1] )
	local val = 0
    if gulag ~= nil then
		for k,v in pairs(gulag.Object) do
			if (v == true or ( v:alive() and
			   not(xr_wounded.is_heavy_wounded_by_id(k) or
				   xr_wounded.is_psy_wounded_by_id(k)))) and
				gulag.Object_begin_job[k] == true
			then
				val = val + 1
			end
		end
	end
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag poulation active["..utils.to_str(val).."]") end
	return val
end

----------once in all.spawn, tutorial_wounded_start
function gulag_inactive(actor, npc, p)
	 local gulag = xr_gulag.get_gulag_by_name( p[1] )
	if gulag ~= nil then 
		for k,v in pairs(gulag.Object) do
			if (v == true or ( v:alive() and
			   not(xr_wounded.is_heavy_wounded_by_id(k) or
				   xr_wounded.is_psy_wounded_by_id(k)))) and
				gulag.Object_begin_job[k] == true
			then
				if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag inactive: false") end
				return false								--(~=0)
			end
		end
		--return true 										--(==0)
	end
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag inactive: true") end
	return true
end

--------once in all.spawn, gar_hellcar_help
function gulag_population_active_le(actor, npc, p)
	local gulag = xr_gulag.get_gulag_by_name( p[1] )
    if gulag ~= nil then
		if p[2] then
			local cnt = 0 + p[2]
			local val = 0
			for k,v in pairs(gulag.Object) do
				if (v == true or ( v:alive() and
				   not(xr_wounded.is_heavy_wounded_by_id(k) or
					   xr_wounded.is_psy_wounded_by_id(k)))) and
					gulag.Object_begin_job[k] == true
				then
					val = val + 1
					if val > cnt then
						if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag active le: false") end
						return false
					end
				end
			end
		end
		if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag active le: true") end
		return true
	end
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag active le: false") end
	return false 
end

-- true, if in that gulag onteri greater than or equal to a given
function gulag_casualities_ge(actor, npc, p)
	if p[1] and p[1] == "esc_blokpost" and not has_alife_info("escape_blockpost_have") then return false end
	local reslt = ( p[1] ~= nil and p[2] ~= nil ) and ( xr_gulag.getCasualities( p[1] ) >= p[2] )
	if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: gulag casualities ge["..utils.to_str(reslt).."]["..utils.to_str(p[1]).."]["..utils.to_str(p[2]).."]") end
	return reslt
end

-- true, If an actor is specified in the inventory item
-- false, if no, or not given a section of the object
function actor_has_item(actor, npc, p)
	return p[1] ~= nil and actor:object( p[1] ) ~= nil
end

-- returns true, if the current scheme of character cocked this signal.
function signal(actor, npc, p)
	if p[1] then
		local st   = db.storage[npc:id()]
		local sigs = st[st.active_scheme].signals
--		printf( "xr_conditions.signal: npc=%s, scheme=%s", npc:name(), tostring(st.active_scheme) )
		return sigs ~= nil and sigs[p[1]] == true
	else
		return false
	end
end

-- returns true, if the value of this counter is an actor more than a specified number of
function counter_greater(actor, npc, p)
	--TB3D_Services.packet_alert("xr cond: counter greater["..utils.to_str(p[1]).."]["..utils.to_str(p[2]).."]")
	if p[1] and p[2] then
		local c = xr_logic.pstor_retrieve(actor, p[1], 0)
		if TB3D_Modders.use_conditions_message == true then TB3D_Services.packet_alert("xr cond: counter greater["..utils.to_str(c).."]>["..utils.to_str(p[2]).."]") end
		return c > p[2]
	else
		return false
	end
end

-- determines the odd interval of playing time. interval needed to transmit a p[1]
function odd_time_interval(actor, npc, p)
	return odd( amk.game_milliseconds() / p[1] )
end

-- current enemy at a distance greater than or equal to the distance
-- for combat_ignore
function fighting_dist_ge(actor, npc, p)
	return db.storage[npc:id()].enemy:position():distance_to( npc:position() ) >= p[1]
end

-------------------------------------------------------------------------------------------------------
-- Options ondderzhki kamp
function _kamp_talk(actor, npc)
	if xr_kamp.kamp_stalkers[npc:id()] then
		return xr_kamp.kamp_stalkers[npc:id()]
	end
	return false
end

function _used(actor, npc)
	return npc:is_talking()
end

-------------------------------------------------------------------------------------------------------
function has_enemy(actor, npc)
	return npc:best_enemy() ~= nil
end

function see_enemy(actor, npc)
    local enemy = npc:best_enemy()
    if enemy ~= nil then 
        return npc:see(enemy) 
    end
    return false
end

-- DELME: for tests: {=test_condition_actor_near}
function test_condition_actor_near(actor, npc)
	if distance_between(actor, npc) <= 3 then
		return true
	end
	return false
end

function talking(actor, npc)
	return actor:is_talking()
end

function talking_or_tutor(actor, npc)
	return actor:is_talking() or has_alife_info("esc_trader_experienced") or has_alife_info("esc_trader_newbie")
end

function see_actor(actor, npc)
	return npc:alive() and npc:see(actor)
end

-- sees a helicopter actor
function heli_see_actor(actor, obj)
	if TB3D_Modders.heli_attack == true then
		return obj:get_helicopter():isVisible(actor)
	else
		return false
	end
end

function actor_enemy(actor, npc)
	local t = db.storage[npc:id()].death
	return npc:relation(actor) == game_object.enemy or (t ~= nil and t.killer == actor:id())
end

function gar_dm_nearest_bandit(actor, npc)
	--printf("_bp: xr_conditions: nearest [%s]? %s", npc:name(),
	--		if_then_else(xr_conditions_impl.gar_dm_nearest_bandit(actor, npc, 1), "true", "false"))
	return xr_conditions_impl.gar_dm_nearest_bandit(actor, npc, 1)
end

function gar_dm_2nd_nearest_bandit(actor, npc)
	--printf("_bp: xr_conditions: 2nd nearest [%s]? %s", npc:name(),
	--		if_then_else(xr_conditions_impl.gar_dm_nearest_bandit(actor, npc, 2), "true", "false"))
	return xr_conditions_impl.gar_dm_nearest_bandit(actor, npc, 2)
end

function trade_exchanged(actor, npc)
	return db.storage[npc:id()].trade.exchanged
end

function trading(actor, npc)
	return db.storage[npc:id()].trade.trading
end

function hit_by_actor(actor, npc)
	local t = db.storage[npc:id()].hit
	local hit_by_actor = t and t.who == db.actor:id()
	return hit_by_actor
end

function hit_by_actor_awm(actor, npc)
	 local t = db.storage[npc:id()].hit
     local hit_by_actor_awm = t and t.who == db.actor:id()
     if hit_by_actor_awm then
		local weapon = db.actor:item_in_slot(2)
		if weapon and weapon:section() == "wpn_awm_new" then
			return true --hit_by_actor_awm
		end
    end
	return false
end

function hit_by_actor_eagle(actor, npc)
	 local t = db.storage[npc:id()].hit
     local hit_by_actor_eagle = t and t.who == db.actor:id()
     if hit_by_actor_eagle then
		local weapon = db.actor:item_in_slot(1)
		if weapon and weapon:section() == "wpn_eagle_m2" then --and not db.actor:item_in_slot(2) then
			--TB3D_Services.packet_alert("xr conditions: ["..npc:name().."] hit_by_actor_eagle[true]")
			return true --hit_by_actor_eagle
		end
    end
	--TB3D_Services.packet_alert("xr conditions: ["..npc:name().."] hit_by_actor_eagle[false]")
	return false
end

function killed_by_actor_svd(actor, npc)
	local t = db.storage[npc:id()].death
	local killed_by_actor_svd = t and t.killer == db.actor:id()
	if killed_by_actor_svd then
		local weapon = db.actor:item_in_slot(2)
		if weapon and weapon:section() == "wpn_svd_foto" then
			return true --killed_by_actor_svd
       end
    end
	return false
end

function killed_by_actor_eagle(actor, npc)
	local t = db.storage[npc:id()].death
	local killed_by_actor_eagle = t and t.killer == db.actor:id()
	if killed_by_actor_eagle then
		if db.actor:active_slot() == 1 then
			local weapon = db.actor:item_in_slot(1)
			if weapon and weapon:section() == "wpn_eagle_m2" then
				--TB3D_Services.packet_alert("xr conditions: ["..npc:name().."] killed_by_actor_eagle[true]")
				return true
			end
		end
    end
	--TB3D_Services.packet_alert("xr conditions: ["..npc:name().."] killed_by_actor_eagle[false]")
	return false --killed_by_actor_eagle
end

function killed_by_actor(actor, npc)	--109976 not realistic, just keep result for checking later
	local result = amk.load_variable("killed_by_actor", 0)
	local t = db.storage[npc:id()].death
	if (t ~= nil and t.killer == actor:id()) then
		local npc_name = protected_items.get_obj_name(npc)			--109998
		if npc_name == "atp_bandit_shnura" then
			result = result + 1
		elseif npc_name == "atp_ataker_bandit23" then
			result = result + 10
		elseif npc_name == "bar_killer_attackers_15" then			--humpback
			result = result + 100
		elseif npc_name == "atp_ataker_bandit24" then
			result = result + 1000
		elseif npc_name == "dsity_rasstrel2" then
			result = result + 10000
		elseif npc_name == "dsity_rasstrel1" then
			result = result + 100000
		end
		if result > 0 then amk.save_variable("killed_by_actor", result) end		--else amk.del_variable("killed_by_actor") end
		--TB3D_Services.packet_alert("killed by actor result["..utils.to_str(result).."]")
		return true				--110010
	end
	return false				--110010
end

function actor_has_weapon(actor, npc)
    local obj = actor:active_item()
    if obj == nil or IAmAWeapon[obj:clsid()] == false then return false end
    return true
end

function heavy_wounded(actor, npc)
	return xr_wounded.is_heavy_wounded_by_id( npc:id() )
end

--[[
Checking for a specified period of time
Time is in minutes
Options: (time_shift:period_min)
           time_shift - frequency response
           period - period of operation in which we onluchaem true

Examples:
time_period(60:10) - return true every hour during the first 10 minutes
--]]
function time_period(actor, npc, p)
    local tshift, period = p[1], p[2]
    if tshift ~= nil and period ~= nil then
        return tshift > period and level.get_time_minutes() % tshift <= period
    end
    return false
end    

function is_day (actor, npc)
	return not TB3D_Services.is_night(false)
    --return level.get_time_hours() >= 6 and level.get_time_hours() < 21
end    

function is_arsenal_guard_rest_time(actor, npc)
    return level.get_time_hours() > 3 and level.get_time_hours() < 5
end

function bar_no_sniper_time(actor, npc)
    return level.get_time_hours() >= 5
end 

function mob_has_enemy(actor, npc)
    -- return false
    if npc == nil then return false end
    --if npc:get_enemy () then printf ("ENEMY PRESENT") else printf ("ENEMY NOT PRESENT") end
    return npc:get_enemy() ~= nil
end    

function mob_actor_nearest(actor, npc)
    return false
    --if npc == nil then return false end
    --printf ("Distance to actor : %d", distance_between (actor, npc))
    --return distance_between (actor, npc) < 20
end    

function mob_was_hit(actor, npc)
	local h = npc:get_monster_hit_info()
	if h.who and h.time ~= 0 then
		return true
	end
	return false
end

-- the current enemy of the actor?
function fighting_actor(actor, npc)
    local enemy = db.storage[npc:id()].enemy
	if enemy and enemy.id then
		if enemy:id() == db.actor:id() then return true end
	end
	return false
end

function dont_fighting_actor(actor, npc)
    local enemy = db.storage[npc:id()].enemy
	if enemy and enemy.id then
		if enemy:id() == db.actor:id() then return false end
	end
	return true
end

-- current enemy at a distance greater than or equal to 20m
function fighting_dist_ge_20(actor, npc)
	return db.storage[npc:id()].enemy:position():distance_to_sqr( npc:position() ) >= 400 -- 20^2
end

-- distance to the current real enemy is greater than or equal to setpoint
function dist_to_enemy_ge(actor, npc, p)
    local d, enemy = p[1], npc:best_enemy()
	return d and enemy and enemy:position():distance_to_sqr(npc:position()) >= d * d
end

-- distance to the current real enemy is less than or equal to the specified value
function dist_to_enemy_le(actor, npc, p)
    local d, enemy = p[1], npc:best_enemy()
	return d and enemy and enemy:position():distance_to_sqr(npc:position()) <= d * d
end

function esc_tutorial_flesh_died_in_anomaly(actor, npc)
	if TB3D_Services.is_collector(500) == true then return true end
	local t = db.storage[npc:id()].death
	if t and t.killer_name then
		if t.killer_name == "esc_tutorial_mincer_02" or
		   t.killer_name == "esc_tutorial_mosquito_bald_01" or
		   t.killer_name == "esc_tutorial_mincer_01" then
			return true
		end
	end
	return false
end

------------------------------------------------------------------------------------
-- Special functions for Garbage
------------------------------------------------------------------------------------
function gar_boars_nest2_dead(actor, npc)
	return gulag_population_le(actor, npc, {"gar_boars_nest2",0})
--	local g = xr_gulag.fraction["gar_boars_nest2"]
--	return (not g) or (g:get_population() == 0)
end

function gar_damaged_bandits(actor, npc)
	if (gulag_population_active(actor, npc, {"gar_bandit_agr"}) <= 5) then
		return true
	end
	return false
end

function gar_angar_sleep(actor,npc)
	return (gulag_empty(actor,npc,{"gar_seryi_bandits"}) and not has_alife_info("agr_krot_band_start")) or
	       (gulag_population_le(actor,npc,{"gar_smart_bandit_large_lager",9}) and has_alife_info("agr_krot_band_start"))
end

function gar_not_damaged_bandits(actor, npc)
	return  not this.gar_damaged_bandits (actor, npc)
end

function gar_bandits_seryi_die()
	if db.actor then
		if gulag_population_active(actor, npc, {"gar_seryi_bandits"}) == 0 then
			return true			
		else
			return false
		end
	else
		return false
	end
end

function gar_bandits_seryi_not_die()
	return not xr_conditions.gar_bandits_seryi_die()
end

------------------------------------------------------------------------------------
-- Special functions for Dark Valley
------------------------------------------------------------------------------------
-- General combat ignore for bandits
function val_bandits_ci(actor, npc)
    local ig = {val_escort_captive_enemy = 400,
                val_sacrifice_finish = 401,
                val_prisoner_free = 402}
	local enemy = db.storage[npc:id()].enemy
	local sid
	if enemy and enemy:alive() then
	    sid = enemy:story_id()
	    for v, i in pairs(ig) do
		    if sid == i then
		        if has_alife_info(v) then
			        return false
			    end
			    return true
		    end
	    end
	end
	return false
end

-- Combat ignore for bandits with checking combat with actor checking
function val_bandits_ci_actor(actor, npc, p)
    local ig = {val_escort_captive_enemy = 400,
                val_sacrifice_finish = 401,
                val_prisoner_free = 402}
	local enemy = db.storage[npc:id()].enemy
	local sid
	if enemy and enemy:alive() then
	    if enemy:id() == actor:id() then
            return npc:position():distance_to_sqr(actor:position()) >= p[1] * p[1]
	    end
	    sid = enemy:story_id()
	    for v, i in pairs(ig) do
		    if sid == i then
		        if has_alife_info(v) then
			        return false
			    end
			    return true
		    end
	    end
	end
	return false
end

-- parameters: [dist]
function val_escort_captive_dist_to_guards_ge(actor, npc, p)
    local d2 = p[1] * p[1]
    local g1 = level_object_by_sid(407)
    if g1 and g1:alive() then
        if npc:position():distance_to_sqr(g1:position()) < d2 then
            --printf("xr_cond <captive_dist_to_guards>: FALSE")
            return false
        end
	end
    local g2 = level_object_by_sid(408)
    if g2 and g2:alive() then
        if npc:position():distance_to_sqr(g2:position()) < d2 then
            --printf("xr_cond <captive_dist_to_guards>: FALSE")
            return false
        end
	end
    --printf("xr_cond <captive_dist_to_guards>: TRUE")
	return true
end

function val_escort_captive_dist_to_guards_le(actor, npc, p)
    local d2 = p[1] * p[1]
    local g1 = level_object_by_sid(407)
    if g1 and g1:alive() then
        if npc:position():distance_to_sqr(g1:position()) > d2 then
            --printf("xr_cond <captive_dist_to_guards>: FALSE")
            return false
        end
	end
    local g2 = level_object_by_sid(408)
    if g2 and g2:alive() then
        if npc:position():distance_to_sqr(g2:position()) > d2 then
            --printf("xr_cond <captive_dist_to_guards>: FALSE")
            return false
        end
	end
    --printf("xr_cond <captive_dist_to_guards>: TRUE")
	return true
end

function val_fighting_captive(actor, npc)
	return db.storage[npc:id()].enemy:story_id() == 400	--db.storage[npc:id()].enemy:name() == "val_escort_captive"
end

function val_escort_combat_end(actor, npc)
	return false
end

function val_hit_by_nap1(actor, npc)
	local nap1 = level_object_by_sid(406)
	if nap1 == nil then return false end
	local t = db.storage[npc:id()].hit
	local hit_by_nap1 = (t ~= nil and t.who == nap1:id())
	--printf("_bp: hit_by_nap1: %s", if_then_else(hit_by_nap1, "true", "false"))
	return hit_by_nap1
end

function val_hit_by_guard(actor, npc)
	local g1 = level_object_by_sid(407)
	local g2 = level_object_by_sid(408)
	if g1 == nil and g2 == nil then return false end
	local t = db.storage[npc:id()].hit
	local hit_by_guard = (t ~= nil and
						  ((g1 ~= nil and t.who == g1:id()) or
						   (g2 ~= nil and t.who == g2:id())
						  ))
	--printf("_bp: hit_by_guard: %s", if_then_else(hit_by_guard, "true", "false"))
	return hit_by_guard
end

function val_fighting_sacrifice_victim(actor, npc)
	return db.storage[npc:id()].enemy:story_id() == 401 --db.storage[npc:id()].enemy:name() == "val_sacrifice_victim"
end    

function val_fighting_prisoner(actor, npc)
	return db.storage[npc:id()].enemy:story_id() == 402 --db.storage[npc:id()].enemy:name() == "val_prisoner_captive"
end    

function val_fighting_sacrifice_bloodsucker(actor, npc)
	return db.storage[npc:id()].enemy:story_id() == 403
end    

function val_actor_in_cage(actor, npc)
	return utils.npc_in_zone(actor, db.zone_by_name["val_prisoner_cage_zone"])
end

function val_actor_has_key_to_underground(actor, npc)
	if xr_conditions_impl.actor_has_object(actor, "val_key_to_underground") then
		--printf("_bp: xr_conditions: val_actor_has_key_to_underground: true")
		return true
	end
	--printf("_bp: xr_conditions: val_actor_has_key_to_underground [actor='%s']: false", actor:name())
	return false
end

--[[
function val_prisoner_in_cage(actor, npc)
	local prisoner = level_object_by_sid(402)
	if not prisoner then
		return false
	end
	return utils.npc_in_zone(prisoner, db.zone_by_name["val_prisoner_cage_zone"])
end
--]]

function actor_wears_bandit_outfit(actor, npc)
	--[[
	local cur_eq = actor:get_current_equipment()
	local wears = cur_eq and cur_eq:name() == "bandit_outfit"
	--printf("_bp: actor_wears_bandits_outfit: %s", utils.to_str(wears))
	return wears
	--]]
	return xr_conditions_impl.actor_has_object(actor, "bandit_outfit")
end

------------------------------------------------------------------------------------
-- Special functions for Pripyat
------------------------------------------------------------------------------------
function pri_followers_can_hear(actor, npc)
	--if TB3D_Services.is_collector() == true then return false end
	local gulag = xr_gulag.get_gulag(823)

    return not has_alife_info("pri_followers_start") or           
           gulag ~= nil and gulag:get_population() > 0 and
           not gulag:npc_is_enemy_to_anybody(actor)
end

function pri_monolith_combat_ignore(actor, npc)
	local enemy = db.storage[npc:id()].enemy
	if enemy and enemy.clsid == clsid.snork_s and enemy:alive() then
        local g = xr_gulag.get_npc_gulag(enemy)
        return g ~= nil and (g.name == "pri_snork_nest1" or g.name == "pri_snork_nest2")
    else
        return false
    end
end

function pri_actor_has_rpg_ammo(actor, npc)
	return actor:object("ammo_og-7b") ~= nil
end

function pri_follower_see_ambush(actor, npc)
	--if TB3D_is_collector() == true then return false end
	local gulag = xr_gulag.get_gulag_by_name("pri_wave7")
    if gulag then
		for k,v in pairs(gulag.Object) do
			if v ~= nil and npc:best_enemy() and npc:best_enemy():id() == v:id() then
				-- printf("[plecha] %s see %s or has enemy %s", utils.to_str(npc), utils.to_str(v), utils.to_str(npc:best_enemy()))
				return true
			end
		end
		--return false				--!!!!TB3D 10992
	--else
		--return true
	end
	return false
end

------------------------------------------------------------------------------------
-- Special functions for Escape
------------------------------------------------------------------------------------
function esc_vagon_all_dead(actor, npc)
	return xr_conditions_impl.esc_vagon_all_dead()
end

function esc_blokpost_night(actor,npc)
	if xr_gulag.getGulagState("esc_blokpost") == 1 then
		return true
	end
	return false
end

function esc_bandits_die(actor,npc)
	if has_alife_info("esc_kill_bandits_quest_kill") or has_alife_info("esc_kill_bandits_noquest_kill") then
		return true
	end
	return false
end

------------------------------------------------------------------------------------
-- Special functions for LabX18
------------------------------------------------------------------------------------
function dar_actor_has_a_key1(actor,npc)
	return xr_conditions_impl.actor_has_object(actor,"ugrum_flash")
end

function dar_actor_has_a_key2(actor,npc)
	return xr_conditions_impl.actor_has_object(actor,"krot_flash")
end

------------------------------------------------------------------------------------
-- Special functions for BAR - ROSTOK
------------------------------------------------------------------------------------
function bar_arena_actor_inside(actor,npc)
	local t = db.zone_by_name["bar_arena_waiter"]
	if t and db.actor then
		if t:inside(db.actor:position()) then
			return true
		end
	end
	return false
end

function bar_arena_actor_fight(actor,npc)
	local t = db.zone_by_name["bar_arena_sr"]
	local tt = db.zone_by_name["bar_arena_waiter"]
	if t and tt and db.actor then
		if t:inside(db.actor:position()) and
		   not tt:inside(db.actor:position())
		then
			return true
		end
	end
	return false
end

function bar_arena_actor_outside(actor,npc)
	local t = db.zone_by_name["bar_arena_waiter_out"]
	if t and db.actor then
		if t:inside(db.actor:position()) then
			return true
		end
	end
	return false
end

function bar_dolg_alarm(actor,npc)
	if xr_gulag.getGulagState("bar_dolg_general") == 2 then
		return true
	end
	if xr_gulag.getGulagState("bar_dolg_veterans") == 2 then
		return true
	end
	return false
end

function bar_hostile_npc(actor,npc)
	--dbglog("bar_hostile_npc(actor='%s', npc='%s')",actor:name(),npc:name())
	-- the bartender zabem, still it does not kill.
	local c = npc:character_community()
	if c == "stalker" or c == "dolg" or c == "ecolog" then
		--dbglog("> bar_hostile_npc(false)")
		return false
	end
	--dbglog("> bar_hostile_npc(true)")
	return true
end

function is_courier_time (actor, npc)
    return level.get_time_hours() >= 22 and level.get_time_hours() < 23
end

function is_controller_dead (actor, npc)
    local c = level_object_by_sid (729)
    if c == nil then return false end
    return not c:alive ()
end

function bar_arena_fight_3_end ()
	return has_alife_info("bar_arena_fight_3_stalker_1_die") and has_alife_info("bar_arena_fight_3_stalker_2_die")
end

function bar_arena_fight_4_end ()
	return has_alife_info("bar_arena_fight_4_stalker_1_die") and has_alife_info("bar_arena_fight_4_stalker_2_die") and has_alife_info("bar_arena_fight_4_stalker_3_die")
end

function bar_arena_fight_5_end ()
	return has_alife_info("bar_arena_fight_5_stalker_1_die") and has_alife_info("bar_arena_fight_5_stalker_2_die")
end

function bar_arena_fight_6_end ()
	return has_alife_info("bar_arena_fight_6_stalker_1_die") and has_alife_info("bar_arena_fight_6_stalker_2_die") and has_alife_info("bar_arena_fight_6_stalker_3_die") and has_alife_info("bar_arena_fight_6_stalker_4_die") and has_alife_info("bar_arena_fight_6_stalker_5_die") and has_alife_info("bar_arena_fight_6_stalker_6_die")
end

function bar_arena_fight_8_end ()
	return has_alife_info("bar_arena_fight_8_stalker_1_die") and has_alife_info("bar_arena_fight_8_stalker_2_die") and has_alife_info("bar_arena_fight_8_stalker_3_die") and has_alife_info("bar_arena_fight_8_stalker_4_die")
end
------------------------------------------------------------------------------------
-- Special functions for Military
------------------------------------------------------------------------------------
function mil_actor_enemy (actor, npc)
    local npc = level_object_by_sid (707)
    if npc == nil or npc:alive () == false then
       npc = level_object_by_sid (702) 
       if npc == nil or npc:alive () == false then
          npc = level_object_by_sid (728)
          if npc == nil then 
             --printf ("NOT LEAVED NPC !!!")
             return
          end
        end         
    end
    return npc:relation (actor) == game_object.enemy
end

function mil_actor_enemy_freedom (actor, npc)
    if relation_registry.community_goodwill ("freedom", actor:id ()) < -500 then
       return true
    end   
    return false
end

------------------------------------------------------------------------------------
-- Special functions for Deadcity
------------------------------------------------------------------------------------
function cit_combat_ignore(actor, npc, p)
    local enemy = db.storage[npc:id()].enemy
    if enemy and enemy:alive() then
        if enemy:id() == actor:id() then
            return p[1] ~= nil and not has_alife_info(p[1])
        elseif enemy:story_id() == 1200 then
            return true
        else
            local g = xr_gulag.get_npc_gulag(enemy)
            local gulags = {cit_kanaliz1 = 1, cit_kanaliz2 = 1, cit_kanaliz3 = 1}
            return g ~= nil and gulags[g] == 1
        end
    end
    return false
end

-------------------------------------------------------------------------------------
-- Special for Agroprom
-------------------------------------------------------------------------------------

function agr_boars_nest_dead(actor, npc)		-- function name
		local g = xr_gulag.fraction["agr_boar_nest"]  -- the name of the gulag
		return (not g) or (g:get_population() == 0)
end

function is_wfx_playing (actor, npc)
    return level.is_wfx_playing ()
end

function agr_nii_pop_check(actor, npc)
	if (gulag_population_active(actor, npc, {"agr_nii"}) < 6) then
		return true
	end
	return false
end

function prizrak_zver_have(actor, npc)											--110000, called by treasure_manager
	return xr_conditions_impl.actor_has_object(actor,"sniper_flash")
end

-------------------------------------------------------------------------------------
-- Special for rostok
-------------------------------------------------------------------------------------
------called by gulag_bar.ltx, kruglov rescue
function rostok_gulag_inactive(actor, npc)
    local gulag = xr_gulag.get_gulag_by_name("bar_freedom_attack")
    if gulag ~= nil then
		local job_prior = 0
		for k,v in pairs(gulag.Object) do
			job_prior = gulag.Job[gulag.ObjectJob[k]].prior
			if (v == true or 
			   (v:alive() and
				not xr_wounded.is_heavy_wounded_by_id(k) and
				not xr_wounded.is_psy_wounded_by_id(k) and
				job_prior == 5)) and gulag.Object_begin_job[k] == true
			then
				return false
			end
		end
	end
	return true
end

--------------agr_krot.ltx
function agr_factory_hold_inactive(actor, npc)
	 local gulag = xr_gulag.get_gulag_by_name("agr_factory_hold")
    if gulag ~= nil then
		for k,v in pairs(gulag.Object) do
			if (v == true or ( v:alive() and
			   not(xr_wounded.is_heavy_wounded_by_id(k) or
				   xr_wounded.is_psy_wounded_by_id(k)))) and
				gulag.Object_begin_job[k] == true
			then
				return false
			end
		end
	end
	return true
end

------------------gulag_bar.ltx
function rostok_gulag_2_inactive(actor, npc)
	 local gulag = xr_gulag.get_gulag_by_name("bar_freedom_chasers_attack")
    if gulag ~= nil then
		for k,v in pairs(gulag.Object) do
			if (v == true or ( v:alive() and
			   not(xr_wounded.is_heavy_wounded_by_id(k) or
				   xr_wounded.is_psy_wounded_by_id(k)))) and
				gulag.Object_begin_job[k] == true
			then
				return false
			end
		end
	end
	return true
end

function rostok_dist_to_actor_le(actor, npc, p)
    local actor = db.actor
    if actor then
	    return npc:position():distance_to_sqr(actor:position()) < p[1]*p[1]
	end
	return false
end

function see_actor_and_kruglov(actor, npc)
	local kruglov = level_object_by_sid (503)
    return npc:see(actor) or npc:see(kruglov)
end

function has_ghost_pda ()
	return db.actor:object ("yantar_ghost_pda") ~= nil
end

-------------------------------------------------------------------------------------
-- Special for Radar
-------------------------------------------------------------------------------------
function rad_pass_time(actor, npc)
	return true
--    return level.get_time_hours() >= 10 and level.get_time_hours() < 11
end

-------------------------------------------------------------------------------------
-- Special for Sarcofag
-------------------------------------------------------------------------------------
function actor_has_decoder(actor, npc)
	return has_alife_info("tb3d_wish_granted") and actor:object("decoder") ~= nil				--110005, after wish granter
end

-------------------------------------------------------------------------------------
-- Special for Trade
-------------------------------------------------------------------------------------
local trade_by_level = {
	l01_escape = "escape",
	l02_garbage = "garbage",
	l03_agroprom = "garbage",
	l03u_agr_underground = "garbage",
	l04_darkvalley = "garbage",
	k01_darkscap = "garbage",
	l04u_labx18 = "garbage",
	l05_bar = "bar",
	l06_rostok = "bar",
	l07_military = "bar",
	l08_yantar = "yantar",
	l08u_brainlab = "yantar",
	dead_city = "yantar",
	l10_radar = "radar",
	l10u_bunker = "radar",
	l11_pripyat = "radar",
	atp_for_test22 = "atp_for_test22r",
	peshera = "peshera",
	puzir = "puzir",
	aver = "aver",
	warlab = "warlab",
	lost_village = "lost_village",
	av_peshera = "av_peshera"
	}
function npc_trade_by_level(actor, npc, p)
	local trade = trade_by_level[level.name()]	
	if trade == nil then
		return false
	end
	if trade == p[1] then
		return true
	else
		return false
	end
end

function actor_in_dolg(actor, npc)
	if db.actor then
		return db.actor:character_community() == "actor_dolg"
	end
	return false
end
function actor_in_freedom(actor, npc)
	if db.actor then
		return db.actor:character_community() == "actor_freedom"
	end
	return false
end

function actor_on_level(actor, npc, p)
	return p[1] == level.name()
end

function treasure_exist(actor, npc, p)
	--printf("%s %s", actor:name(), npc:name())
	return true
end

function can_send_tutorial(actor, npc, p)
	if db.actor:is_talking() 
		or game.has_active_tutorial()
		or has_alife_info("ui_inventory")
		or has_alife_info("ui_pda") then
		return false
	end
	return true
end

---------------------------------------------------------------ARENA_EXTENSION_MOD------------------------------------------------------------------
-- These two functions should not be duplicated in the file
-- original must be removed

function bar_actor_rank_stalker (actor,npc)
	if db.actor:character_rank() > 300 or
		has_alife_info("bar_arena_fight_8_done") then
		return true
	end
end

function bar_actor_rank_veteran (actor,npc)
	if db.actor:character_rank() > 600 or
		has_alife_info("bar_arena_fight_8_done") then
		return true
	end
end

---------------------------------------------------------------ARENA_EXTENSION_MOD------------------------------------------------------------------
---------------------------------------------------------------ARENA_EXTENSION_MOD------------------------------------------------------------------
function aem_group(actor, npc, p)
	return aem_manager.get_aem():is_group_name(p[1])
end

function aem_intro(actor, npc, p)
	return aem_manager.get_aem():is_intro_name(p[1])
end

function aem_extro(actor, npc, p)
	return aem_manager.get_aem():is_extro_name(p[1])
end

function aem_check_blow()
	if TB3D_Services.blow() then		--109980
		return true
	end
	return false
end

function aem_evil()
	return aem_manager.get_aem():is_stalkers_evil()
end

function aem_kind()
	return not aem_manager.get_aem():is_stalkers_evil()
end

function aem_on_place(actor, npc)
	-- bar_arena_man_look
	local pos = npc:position()
	if (pos.x>148.8 and pos.x<157.7) and (pos.z>68.3 and pos.z<69.9) then
		return true
	end
	return false
end

---------------------------------------------------------------ARENA_EXTENSION_MOD------------------------------------------------------------------
