-- TB3D 1.1.0.0.0.4 added tables to debug, new rep system, optimized, cleanup, db calls, added intervals,
--show_tables, generic_m_story_id, post process, is_spawner, get_level_index
prefetch("TB3D_Modders")
function my_ver() return "1.1.0.0.0.4" end

if (jit == nil) then
  profiler.setup_hook()
end

winx = 1024			--109976 from bind_stalker
hwinx = 512
winy = 768

generic_m_story_id = 4294967296					--engine: non essential spawns in all.spawn given this SID
value_65535 = 65535								--for hash/math
first_object = 1								--always start at 1, 0=actor
last_object = value_65535						--max in loops, 65,535 objects, 0 based = (actor)
expendable_object = value_65535					--sak/dmx/smt PID 65535 = unimportant objects to be cleaned when dead and other functions
is_disconnecting = true							--start out blocking protected items and holding off updates until actor:on_spawn is done
slice_interval_1sec = 1000						--pre calculated intervals for optimized loop speed, xrs_medic
slice_interval_2sec = slice_interval_1sec * 2
slice_interval_3sec = slice_interval_1sec * 3
slice_interval_5sec = slice_interval_1sec * 5
slice_interval_10sec = slice_interval_1sec * 10
slice_interval_20sec = slice_interval_1sec * 20
slice_interval_30sec = slice_interval_1sec * 30
slice_interval_1min = slice_interval_1sec * 60
slice_interval_3min = slice_interval_1min * 3
get_nervous = 0 --1												--109981, blow_phase to react to
run_hide = 1 --2
huddle_up = 3
can_leave = 6
is_spawner = false									--109998, bypass pop control if from spawn menu
time_changed = true									--110000, used to reset weather in bind_stalker.update
delta_100 = 0
near_enemy_count = 1								--110004, for display on hud

-- Loads the schema from a file on the disk and activates a motivator.
-- Here:
--  filename - file name, which implemented the scheme, with no extension
--  scheme - schema name
function load_scheme(filename, scheme, stype)
  db.schemes[scheme] = filename
  db.stypes[scheme] = stype
  if TB3D_Modders.use_scheme_message == true then TB3d_Services.packet_alert("_g: load scheme["..utils.to_str(filename).."]["..utils.to_str(stype).."]") end
end
-------======= ini reading functions by sapsan =======------
iniLines = {
    ["float"]   = {},
    ["u32"]   = {},
    ["string"]  = {},
    ["string_wq"]  = {},
    ["boolean"] = {},
    ["line"] = {}
}
iniOtherLines = {}
iniStat = {}
iniCaching = true
--iniStatistic = true
iniStatistic = false
iniSections = {} -- if empty - cached EVERYTHING!
iniSectionsCount = 0
for sect, val in pairs(iniSections) do
    iniSectionsCount = iniSectionsCount + 1
end

function getIniValueFloat(sect, line, default, iniFileName)
	--TB3D_Services.packet_alert("_G: getIniValueFloat")
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then iniStat[sect] = iniStat[sect] + 1 else iniStat[sect] = 1 end
        end
		--TB3D_Services.info_alert("_g  getinivalueFloat")
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["float"]
			or not iniOtherLines[iniFileName]["float"][sect]
			or not iniOtherLines[iniFileName]["float"][sect][line])
			or (not iniLines["float"][sect] or not iniLines["float"][sect][line]) then
                local ini, sectLines = getIniValuePrepare("float", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_float(sect, line)
                else
                    sectLines[line] = default
                end
            end
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["float"][sect][line]
            else
                return iniLines["float"][sect][line]
            end
        else
            local ini
            if iniFileName then ini = ini_file(iniFileName) else ini = system_ini() end
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_float(sect, line)
            end
        end
    end
	--TB3D_Services.packet_alert("_G: getIniValueFloat done")
    return default
end

function getIniValueU32(sect, line, default, iniFileName)
	--TB3D_Services.packet_alert("_G: getIniValueU32")
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then iniStat[sect] = iniStat[sect] + 1 else iniStat[sect] = 1 end
        end
		--TB3D_Services.info_alert("_g  getinivalueU32")
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName]
			or not iniOtherLines[iniFileName]["u32"]
			or not iniOtherLines[iniFileName]["u32"][sect]
			or not iniOtherLines[iniFileName]["u32"][sect][line])
			or (not iniLines["u32"][sect] or not iniLines["u32"][sect][line]) then
                -- amk.dump_table(iniLines)
                local ini, sectLines = getIniValuePrepare("u32", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_u32(sect, line) else sectLines[line] = default
                end
            end
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["u32"][sect][line]
            else
                return iniLines["u32"][sect][line]
            end
         else
            local ini
            if iniFileName then ini = ini_file(iniFileName) else ini = system_ini() end
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_u32(sect, line)
            end
        end
    end
	--TB3D_Services.packet_alert("_G: getIniValueU32 done")
    return default
end

function getIniValueString(sect, line, default, iniFileName)
	--TB3D_Services.packet_alert("_G: getIniValueString")
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then iniStat[sect] = iniStat[sect] + 1 else iniStat[sect] = 1 end
        end
		--TB3D_Services.info_alert("_g  getinivaluestring")
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["string"]
			or not iniOtherLines[iniFileName]["string"][sect]
			or not iniOtherLines[iniFileName]["string"][sect][line])
			or (not iniLines["string"] or not iniLines["string"][sect] or not iniLines["string"][sect][line]) then
                local ini, sectLines = getIniValuePrepare("string", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_string(sect, line)
                else
                    sectLines[line] = default
                end
            end
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["string"][sect][line]
            else
                return iniLines["string"][sect][line]
            end
        else
            local ini
            if iniFileName then ini = ini_file(iniFileName) else ini = system_ini() end
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_string(sect, line)
            end
        end
    end
	--TB3D_Services.packet_alert("_G: getIniValueString done")
    return default
end

function getIniValueStringWQ(sect, line, default, iniFileName)
	--TB3D_Services.packet_alert("_G: getIniValueStringWQ")
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then iniStat[sect] = iniStat[sect] + 1 else iniStat[sect] = 1 end
        end
       --TB3D_Services.info_alert("_g  getinivaluestringwq")
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["string_wq"] or not iniOtherLines[iniFileName]["string_wq"][sect] or not iniOtherLines[iniFileName]["string_wq"][sect][line]) or
                (not iniLines["string_wq"] or not iniLines["string_wq"][sect] or not iniLines["string_wq"][sect][line]) then
                local ini, sectLines = getIniValuePrepare("string_wq", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_string_wq(sect, line)
                else
                    sectLines[line] = default
                end
            end
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["string_wq"][sect][line]
            else
                return iniLines["string_wq"][sect][line]
            end
        else
            local ini
            if iniFileName then ini = ini_file(iniFileName) else ini = system_ini() end
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_string_wq(sect, line)
            end
        end
    end
	--TB3D_Services.packet_alert("_G: getIniValueStringWQ done")
   return default
end

function getIniValueBool(sect, line, default, iniFileName)
	--TB3D_Services.packet_alert("_G: getIniValueBool")
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then iniStat[sect] = iniStat[sect] + 1 else iniStat[sect] = 1 end
        end
		--TB3D_Services.info_alert("_g  getinivalueBool")
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName]
			or not iniOtherLines[iniFileName]["boolean"]
			or not iniOtherLines[iniFileName]["boolean"][sect]
			or iniOtherLines[iniFileName]["boolean"][sect][line] == nil)
			or (not iniLines["boolean"][sect] or iniLines["boolean"][sect][line] == nil) then
                local ini, sectLines = getIniValuePrepare("boolean", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_bool(sect, line)
                else
                    sectLines[line] = default
                end
            end
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["boolean"][sect][line]
            else
                return iniLines["boolean"][sect][line]
            end
        else
            local ini
            if iniFileName then ini = ini_file(iniFileName) else ini = system_ini() end
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_bool(sect, line)
            end
        end
    end
	--TB3D_Services.packet_alert("_G: getIniValueBool done")
    return default
end

function iniLinesCount(sect, iniFileName)
    if sect then
		--TB3D_Services.info_alert("_g  iniLinesCount")
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName]
			or not iniOtherLines[iniFileName]["line"]
			or not iniOtherLines[iniFileName]["line"][sect]
			or not iniOtherLines[iniFileName]["line"][sect]["count"])
			or (not iniLines["line"] or not iniLines["line"][sect] or not iniLines["line"][sect]["count"]) then
                --get_console():execute("load ~~~ iniCaching iniLinesCount: 1")
                local ini, sectLines = getIniValuePrepare("line", sect, iniFileName)
                if iniLineSectionExist(sect, iniFileName) then
                    sectLines["count"] = ini:line_count(sect)
                else
                    sectLines["count"] = 0
                end
            end
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["line"][sect]["count"]
            else
                return iniLines["line"][sect]["count"]
            end
        else
            local ini
            if iniFileName then ini = ini_file(iniFileName) else ini = system_ini() end
            if ini and ini:section_exist(sect) then return ini:line_count(sect) end
        end
    end
    return 0
end

function iniLineSectionExist(sect, iniFileName)
	--TB3D_Services.packet_alert("_G: iniLineSectionExist")
    if sect then
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName]
			or not iniOtherLines[iniFileName]["line"]
			or not iniOtherLines[iniFileName]["line"][sect]
			or iniOtherLines[iniFileName]["line"][sect]["exist"] == nil)
			or (not iniLines["line"] or not iniLines["line"][sect] or iniLines["line"][sect]["exist"] == nil) then
                local ini, sectLines = getIniValuePrepare("line", sect, iniFileName)
                sectLines["exist"] = (ini and ini:section_exist(sect))
            end
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["line"][sect]["exist"] -- > -1
            else
                return iniLines["line"][sect]["exist"] -- > -1
            end
        else
            local ini
            if iniFileName then ini = ini_file(iniFileName) else ini = system_ini() end
            return (ini and ini:section_exist(sect))
        end
    end
	--TB3D_Services.packet_alert("_G: iniLineSectionExist done")
    return false
end

function getIniLine(sect, lineNumber, defaultKey, defaultValue, iniFileName)
	--TB3D_Services.packet_alert("_G: getIniLine")
    if sect and lineNumber then
        if iniStatistic then
            if iniStat[sect] then iniStat[sect] = iniStat[sect] + 1 else iniStat[sect] = 1 end
        end
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName]
			or not iniOtherLines[iniFileName]["line"]
			or not iniOtherLines[iniFileName]["line"][sect]
			or not iniOtherLines[iniFileName]["line"][sect]["lines"]
			or not iniOtherLines[iniFileName]["line"][sect]["lines"][lineNumber])
			or (not iniLines["line"]
			or not iniLines["line"][sect]
			or not iniLines["line"][sect]["lines"]
			or not iniLines["line"][sect]["lines"][lineNumber]) then
                local ini, sectLines = getIniValuePrepare("line", sect, iniFileName)
                if not sectLines["lines"] then sectLines["lines"] = {} end
                local result, key, value = ini:r_line(sect, lineNumber, defaultKey, defaultValue)
                sectLines["lines"][lineNumber] = {result, key, value}
            end
            -- amk.dump_table(iniLines)
            local t
            if iniFileName then
                t = iniOtherLines[iniFileName]["line"][sect]["lines"][lineNumber]
            else
                t = iniLines["line"][sect]["lines"][lineNumber]
            end
            return t[1], t[2], t[3]
        else
            local ini
            if iniFileName then ini = ini_file(iniFileName) else ini = system_ini() end
            if ini and ini:section_exist(sect) then
                return ini:r_line(sect, lineNumber, defaultKey, defaultValue)
            end
        end
    end
	--TB3D_Services.packet_alert("_G: getIniLine done")
    return false, defaultKey, defaultValue
end

function getIniValuePrepare(valueType, sect, iniFileName)
	--TB3D_Services.packet_alert("_G: getIniValuePrepare")
    local ini
    local sectLines
    if iniFileName then
        ini = ini_file(iniFileName)
        if not iniOtherLines[iniFileName] then
            iniOtherLines[iniFileName] = {}
        end
        if not iniOtherLines[iniFileName][valueType] then
            iniOtherLines[iniFileName][valueType] = {}
        end
        if not iniOtherLines[iniFileName][valueType][sect] then
            iniOtherLines[iniFileName][valueType][sect] = {}
        end
        sectLines = iniOtherLines[iniFileName][valueType][sect]
    else
        ini = system_ini()
        if not iniLines[valueType] then
            iniLines[valueType] = {}
        end
        if not iniLines[valueType][sect] then
            iniLines[valueType][sect] = {}
        end
        sectLines = iniLines[valueType][sect]
    end
	--TB3D_Services.packet_alert("_G: getIniValuePrepare done")
	return ini, sectLines
end
-------======= / ini reading functions by sapsan =======------
----------------------------------------------------------------------

function printf(fmt,...)	--!!!!TB3D OVERRIDE!!!!! called by shaders, do NOT use or CHANGE
    if TB3D_Modders.use_scheme_message == true then TB3D_Services.packet_alert("_G: internal ["..string.format(fmt,...).."]") end
end

----------------------------------------------------------------------
if time_global == nil then
  time_global = function() return device():time_global() end
end

function wait_game(time_to_wait)
    verify_if_thread_is_running()
    if (time_to_wait == nil) then
        coroutine.yield()
    else
        local time_to_stop = game.time() + time_to_wait
        while game.time() <= time_to_stop do
            coroutine.yield()
        end
    end
end

function wait(time_to_wait)
    verify_if_thread_is_running()
    if (time_to_wait == nil) then
        coroutine.yield()
    else
        local time_to_stop = time_global() + time_to_wait
        while time_global() <= time_to_stop do
            coroutine.yield()
        end
    end
end

function action(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,false)
    end
    return  entity_action(act)
end

function action_first(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,true)
    end
    return  entity_action(act)
end

function round (value)
    local min = math.floor (value)
    local max = min + 1
    if value - min > max - value then return max end
    return min
end

--// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--// !!!!! will not see ERRORS IN INSTALLATION OF OBJECTS !!!!!
--// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
function debug_get_level_object(obj_name)
    local res = level.debug_object(obj_name)
    while res == nil do
        --printf("get_level_object() is waiting for object \"%s\"", obj_name)
        res         = level.object(obj_name)
        wait        ()
    end
    return          res
end

function debug_get_actor()
    local res       = level.debug_actor()
    while res == nil do
        res         = level.debug_actor()
        wait        ()
    end
    return          res
end

function distance_between(obj1, obj2)
    return obj1:position():distance_to(obj2:position())
end

--// If one object is nil, for example, there is no actor, then we assume that it is far
function distance_between_safe(obj1, obj2)
    if(obj1 == nil or obj2 == nil) then return 100000 end
  return obj1:position():distance_to(obj2:position())
end

--' Checking info portion, even if the player does not exist
function has_alife_info(info_id)
	if alife() then
		return alife():has_info(0, info_id)
	end
	if not db.actor then TB3D_Services.packet_alert("_g: has alife info[no actor yet]  !!!!!!") end
	return false
end

--------------------------------------------------
-- 'lass LUA realizu' rd Finite State Machine
-- control characters
--------------------------------------------------
class 'FSM'

--  initialized by setting the object Non-Player Character
function FSM:__init(script_name, npc_obj)
	--TB3D_Services.packet_alert("FSM init for NPC["..utils.to_str(self.object:name()).."]")
    -- pointer to podkontrolnvy NPC
    self.npc = npc_obj
    -- line - the name of the script runs the game kotorvy
    self.script_name = script_name
    -- matrix zada th state transition graph
    -- implemented as a two-dimensional table
    self.transition_matrix = {[0] = {}}
    -- number of its current state
    self.current_state = 0
    -- flag that the car vklchena
    self.machine_running = true
    --printf("inialization FSM for NPC %s", self.npc:name())
end

function FSM:is_running()
    return self.machine_running
end

function FSM:start()
    --printf("starting FSM for %s", self.npc:name())
    self.machine_running = true
end

function FSM:stop()
    --printf("stoping FSM for %s", self.npc:name())
    self.machine_running = false
    self:reset_script_control()
end

--  adding a pointer to a Boolean
--  funktsi conditions for transition
function FSM:set_transition(from_state_num, to_state_num, cond_func)
    --printf("in setting transition %d, %d ", from_state_num, to_state_num)
    if self.transition_matrix[from_state_num] == nil then
       self.transition_matrix[from_state_num] = {[to_state_num] = cond_func}
    else
       self.transition_matrix[from_state_num][to_state_num] = cond_func
    end
end

-- identity verification FSM
function FSM:run()
	--TB3D_Services.packet_alert("run FSM for NPC["..utils.to_str(self.object:name()).."]")
    local transition_vector = self.transition_matrix[self.current_state]
    table.foreach(transition_vector,
		function(to_state_num, cond_func)
			if cond_func(self.npc, self) == true then
				--printf("transition from %d to %d", self.current_state, to_state_num)
				if to_state_num == 0 then
					self:reset_script_control()
				end
				--if  self.current_state == 0 then
				--  self:set_script_control()
				--end
				self.current_state = to_state_num
				return true
			end
			return nil
		end)
end

-- run an infinite loop FSM			!!!!TB3D    GAME LOOP
function FSM:run_loop()
	--TB3D_Services.packet_alert("running FSM loop for NPC["..utils.to_str(self.object:name()).."]")
    while self:is_running() do
        local transition_vector = self.transition_matrix[self.current_state]
        table.foreach(transition_vector,
			function(to_state_num, cond_func)
				if cond_func(self.npc, self) == true then
					--printf("transition from %d to %d", self.current_state, to_state_num)
					if to_state_num == 0 then
						self:reset_script_control()
					end
					--if  self.current_state == 0 then
					--  self:set_script_control()
					--end
					self.current_state = to_state_num
					return true
				end
				return nil
			end)
        if self.npc:alive() == false then
           self.npc:script(false, self.script_name)
           return
        end
        wait()
    end
end

-- taking control of the script NPC (the transition from the zero state)
function FSM:set_script_control()
    --printf("set script control for FSM of NPC %s", self.npc:name())
    self.npc:script(true, self.script_name)
end

-- letting go of control script NPC (the transition to the zero state)
function FSM:reset_script_control()
    --printf("reset script control for FSM of NPC %s", self.npc:name())
    self.npc:script(false, self.script_name)
end
--------------------------------------------------
-- end of  class 'FSM'
--------------------------------------------------

function reset_action (npc, script_name)
    if npc:get_script () then
       npc:script (false, script_name)
    end
    npc:script (true, script_name)
end

class "script_object"

function script_object:__init(self,name,script,...)
  self.action         = action(nil,...)
  self.object_name    = name
  self.script_name    = script
  self.object         = nil
end

function script_object:update()
    local                   obj = self.object
    self.object             = level.object(self.object_name)
    if ((obj == nil) and (self.object ~= nil)) then
        self.object:script  (true,self.script_name)
        self.object:command (self.action,false)
    end
end

--
-- transfer the character information
--
function GiveInfoViaPda(obj_receiver, obj_sender, info_number)
	--TB3D_Services.packet_alert("_g: GiveInfoViaPda["..utils.to_str(info_number).."] from["..utils.to_str(obj_sender).."]")
    obj_receiver:give_info_portion_via_pda(info_number, obj_sender)
end

--------------------------------------------------
-- Functions and variables added by Zmey
--------------------------------------------------
-- onstant, used in areas where you need to define an unlimited duration
time_infinite = 100000000

-- prevents hangs in some events
function interrupt_action(who, script_name)
  if who:get_script() then
    who:script(false, script_name)
  end
end

function random_choice(...)
    local arg = {...}
    local r = math.random(1, #arg)
    return arg[r]
end

function new_action(...)
    local arg = {...}
    local act = entity_action()
    for i = 1, #arg do
        act:set_action(arg[i])
    end
    return act;
end

obj_last_actions = {}

function perform_action(obj, action_name, action)
  if (obj ~= nil) then
    obj_last_actions[obj] = action_name
    obj:command(act, false)
  end
end

function last_action(obj)
  return obj_last_actions[obj]
end

function if_then_else(cond, if_true, if_false)
    if cond then
        return if_true
    end
    return if_false
end

function update_action(npc, script, ...)
    local arg = {...}
    if npc == nil then return end
    local act = npc:action ()
    if arg.n == 0 then return end
    if act == nil then act = entity_action () end
    for a = 1, arg.n, 1 do
        if arg[a] ~= nil then act:set_action (arg[a]) end
    end
    reset_action (npc, script)
    npc:command (act, false)
end

function set_current_time(hour, min, sec)
    local current_time_factor = level.get_time_factor()
    --printf ("Need time : %d:%d:%d", hour, min, sec)
    local current_time = game.time()
    local c_day = math.floor(current_time / 86400000)
    local c_time = current_time - c_day * 86400000
    local n_time = (sec + min * 60 + hour * 3600) * 1000
    if c_time > n_time then c_day = c_day + 1 end
    n_time = n_time + c_day * 86400000
    level.set_time_factor (10000)
    while game.time() < n_time do wait() end
    level.set_time_factor(current_time_factor)
end

if (editor() == false) then
class "pp_effector" (effector)

function pp_effector:__init(effector_type,start_time,dest_power,life_time) super(effector_type,start_time)
    self.start_time = start_time
    self.stop_time  = start_time + life_time
    self.max_power  = dest_power
end

function pp_effector:process(pp)
    effector.process(self,pp)
    local curr_time = time_global()
    local d = 0.0
    if curr_time < self.start_time then
        d = 0.0
    else
        if curr_time < self.stop_time then
            d = (curr_time - self.start_time) / (self.stop_time - self.start_time)
        else
            self.info = self.max_power
            return true
        end
    end
    local dual      	= duality()
    local noise     	= noise()
    local base      	= color()
    local gray      	= color()
    local add       	= color()
    dual.h          	= self.max_power.dual.h * d
    dual.v          	= self.max_power.dual.v * d
    noise.grain     	= self.max_power.noise.grain * d
    noise.intensity     = self.max_power.noise.intensity * d
    noise.fps			= self.max_power.noise.fps * d
    base.r          	= self.max_power.color_base.r * d
    base.g				= self.max_power.color_base.g * d
    base.b				= self.max_power.color_base.b * d
    gray.r				= self.max_power.color_gray.r * d
    gray.g				= self.max_power.color_gray.g * d
    gray.b				= self.max_power.color_gray.b * d
    add.r				= self.max_power.color_add.r * d
    add.g				= self.max_power.color_add.g * d
    add.b				= self.max_power.color_add.b * d
    pp.gray				= self.max_power.gray * d
    pp.blur				= self.max_power.blur * d
    pp.dual				= dual
    pp.noise			= noise
    pp.color_base       = base
    pp.color_gray       = gray
    pp.color_add        = add
    self.info			= pp
    return true
end

function pp_effector:finished()
    return self.stop_time < time_global()
end

--
-- postprocess for rainbow
--
class "pp_linear_lerp" (effector)

function pp_linear_lerp:__init(effector_type,start_time,life_time,start_power,dest_power) super(effector_type,start_time)
    self.start_time = start_time
    self.stop_time  = start_time + life_time
    self.min_power  = start_power
    self.max_power  = dest_power
end

function pp_linear_lerp:process(pp)
    effector.process(self,pp)
    local curr_time = time_global()
    local d = 0.0
    if curr_time < self.start_time then
        d = 0.0
    else
        if curr_time < self.stop_time then
            d = (curr_time - self.start_time) / (self.stop_time - self.start_time)
        else
            self.info = self.max_power
            return true
        end
    end
    local dual      	= duality()
    local noise     	= noise()
    local base      	= color()
    local gray      	= color()
    local add       	= color()
    dual.h          	= self.min_power.dual.h + (self.max_power.dual.h - self.min_power.dual.h ) * d
    dual.v          	= self.min_power.dual.v + (self.max_power.dual.v - self.min_power.dual.v ) * d
    noise.grain     	= self.min_power.noise.grain + (self.max_power.noise.grain - self.min_power.noise.grain) * d
    noise.intensity     = self.min_power.noise.intensity + (self.max_power.noise.intensity - self.min_power.noise.intensity) * d
    noise.fps       	= self.min_power.noise.fps + (self.max_power.noise.fps - self.min_power.noise.fps ) * d
    base.r          	= self.min_power.color_base.r + (self.max_power.color_base.r - self.min_power.color_base.r) * d
    base.g          	= self.min_power.color_base.g + (self.max_power.color_base.g - self.min_power.color_base.g) * d
    base.b          	= self.min_power.color_base.b + (self.max_power.color_base.b - self.min_power.color_base.b) * d
    gray.r          	= self.min_power.color_gray.r + (self.max_power.color_gray.r - self.min_power.color_gray.r) * d
    gray.g          	= self.min_power.color_gray.g + (self.max_power.color_gray.g - self.min_power.color_gray.g) * d
    gray.b          	= self.min_power.color_gray.b + (self.max_power.color_gray.b - self.min_power.color_gray.b) * d
    add.r           	= self.min_power.color_add.r + (self.max_power.color_add.r - self.min_power.color_add.r) * d
    add.g           	= self.min_power.color_add.g + (self.max_power.color_add.g - self.min_power.color_add.g) * d
    add.b           	= self.min_power.color_add.b + (self.max_power.color_add.b - self.min_power.color_add.b) * d
    pp.gray         	= self.min_power.gray + (self.max_power.gray - self.min_power.gray) * d
    pp.blur         	= self.min_power.blur + (self.max_power.blur - self.min_power.blur) * d
    pp.dual         	= dual
    pp.noise        	= noise
    pp.color_base       = base
    pp.color_gray       = gray
    pp.color_add        = add
    self.info       	= pp
    return true
end

function pp_linear_lerp:finished()
    return          self.stop_time < time_global()
end
--
-- end of postprocess for rainbow
--

----------------------------------------------------------------------------------------------------------------------
-- Evaluators
----------------------------------------------------------------------------------------------------------------------
-- id numbers from 0 to 256 to create standard evaluators.

--Constant evaluator
class "const_evaluator" (property_evaluator)

function const_evaluator:__init(name, value) super (nil, name)
    self.value = value
end

function const_evaluator:evaluate()
    return self.value
end

--Wait evaluator
class "wait_evaluator" (property_evaluator)

function wait_evaluator:__init(wait_time) super ()
    self.wait_time = wait_time
    self.first_call = true
    self.current_time = 0
end

function wait_evaluator:evaluate ()
    if self.first_call == true then
       self.first_call = false
       self.current_time = device():time_global ()
    else
		local t = device():time_global() - self.current_time
		if t > self.wait_time then return true end
	end
    return false
end
--------------------------------------------------------------------------------
class "enabled_evaluator" (property_evaluator)

function enabled_evaluator:__init(name, storage) super ()
    self.a = storage
end

function enabled_evaluator:evaluate()
    return  self.a.enabled
end

end ---------------------------------------------------- end of editor() == false

function str_split(str)
		if TB3D_Modders.Global_Debug then TB3D_Services.info_alert("_g: str_split") end
    local strlen = string.len (str)
    local parts = {{}, {}, {}, {}}
    local cpart = 1
    for a = 1, strlen, 1 do
        local char = string.byte(str, a)
        if char ~= 95 then
           table.insert(parts[cpart], char)
        else
           cpart = cpart + 1
           if cpart > 4 then break end
        end
    end
    if cpart ~= 4 then return "unknown", "stalker", 0, 0 end
    local str1 = string.char ()
    local str2 = string.char ()
    local str3 = string.char ()
    local str4 = string.char ()
    local ref = parts[1]
    for a = 1, #ref, 1 do
        str1 = string.format("%s%c", str1, ref[a])
    end
    ref = parts[2]
    for a = 1, #ref, 1 do
        str2 = string.format("%s%c", str2, ref[a])
    end
    ref = parts[3]
    for a = 1, #ref, 1 do
        str3 = string.format("%s%c", str3, ref[a])
    end
    ref = parts[4]
    for a = 1, #ref, 1 do
        str4 = string.format("%s%c", str4, ref[a])
    end
    --printf ("%s %s %d %d", str1, str2, str3, str4)
		if TB3D_Modders.Global_Debug then TB3D_Services.info_alert("_g: str_split done") end
    return str1, str2, (str3 + 1) - 1, (str4 + 1) - 1
end

function random_number(min_value, max_value)
    math.randomseed (device ():time_global ())
    if min_value == nil and max_value == nil then
      return math.random ()
    else
      return math.random (min_value, max_value)
    end
end

local ms_per_day = 24 * 60 * 60 * 1000
function day_time()
    return math.mod( game.time(), ms_per_day )
end

--Time in hours
function local_hours()
    return math.floor( math.mod( game.time()/1000, 86400 )/ 3600 )
end

function parse_names( s )
    local t = {}
    for name in string.gfind( s, "([%w_\\]+)%p*" ) do
        table.insert( t, name )
    end
    return t
end

function parse_key_value( s )
    local t = {}
  if s == nil then
    return nil
  end
    local key, nam = nil, nil
    for name in string.gfind( s, "([%w_\\]+)%p*" ) do
    if key == nil then
      key = name
    else
      t[key] = name
      key = nil
    end
    end
    return t
end

function parse_nums( s )
  local t = {}
  for entry in string.gfind( s, "([%d%.]+)%,*" ) do
    table.insert( t, tonumber( entry ) )
  end
  return t
end

function is_object_online(obj_id)
  return level.object_by_id(obj_id) ~= nil
end

function get_clsid(npc)
	if npc and npc.clsid then
		return npc:clsid()
	else
		return
	end
end

--[[ 
function isWeapon(object)
    local id = get_clsid(object)
    if id == nil then return false end
    if id == clsid.wpn_vintorez_s then return true
    elseif id == clsid.wpn_ak74_s then return true
    elseif id == clsid.wpn_lr300_s then return true
    elseif id == clsid.wpn_hpsa_s then return true
    elseif id == clsid.wpn_pm_s then return true
    elseif id == clsid.wpn_shotgun_s then return true
    elseif id == clsid.wpn_bm16_s then return true
    elseif id == clsid.wpn_svd_s then return true
    elseif id == clsid.wpn_svu_s then return true
    elseif id == clsid.wpn_rpg7_s then return true
    elseif id == clsid.wpn_val_s then return true
    elseif id == clsid.wpn_walther_s then return true
    elseif id == clsid.wpn_usp45_s then return true
    elseif id == clsid.wpn_groza_s then return true
    elseif id == clsid.wpn_knife_s then return true
    elseif id == clsid.wpn_grenade_launcher then return true
    elseif id == clsid.wpn_grenade_f1 then return true
    elseif id == clsid.wpn_grenade_rpg7 then return true
    elseif id == clsid.wpn_grenade_rgd5 then return true
    elseif id == clsid.wpn_grenade_fake then return true
    else return false end
end]]
--[[local clsid_weapon_full = {
    [clsid.wpn_ak74_s]              = true,
    [clsid.wpn_bm16_s]              = true,
    [clsid.wpn_fn2000]              = true,
    [clsid.wpn_fort]                = true,
    [clsid.wpn_grenade_f1]          = true,
    [clsid.wpn_grenade_fake]        = true,
    [clsid.wpn_grenade_launcher]    = true,
    [clsid.wpn_grenade_rgd5]        = true,
    [clsid.wpn_grenade_rpg7]        = true,
    [clsid.wpn_groza_s]             = true,
    [clsid.wpn_hpsa_s]              = true,
    [clsid.wpn_knife_s]             = true,
    [clsid.wpn_lr300_s]             = true,
    [clsid.wpn_pm_s]                = true,
    [clsid.wpn_rg6_s]               = true,
    [clsid.wpn_rpg7_s]              = true,
    [clsid.wpn_shotgun_s]           = true,
    [clsid.wpn_svd_s]               = true,
    [clsid.wpn_svu_s]               = true,
    [clsid.wpn_usp45_s]             = true,
    [clsid.wpn_val_s]               = true,
    [clsid.wpn_vintorez_s]          = true,
    [clsid.wpn_walther_s]           = true
}]]
function isWeapon(object)
local clsid_weapon = {
    [clsid.wpn_ak74_s]              = true,
    [clsid.wpn_bm16_s]              = true,
    [clsid.wpn_grenade_f1]          = true,
    [clsid.wpn_grenade_fake]        = true,
    [clsid.wpn_grenade_launcher]    = true,
    [clsid.wpn_grenade_rgd5]        = true,
    [clsid.wpn_grenade_rpg7]        = true,
    [clsid.wpn_groza_s]             = true,
    [clsid.wpn_hpsa_s]              = true,
    [clsid.wpn_knife_s]             = true,
    [clsid.wpn_lr300_s]             = true,
    [clsid.wpn_pm_s]                = true,
    [clsid.wpn_rpg7_s]              = true,
    [clsid.wpn_shotgun_s]           = true,
    [clsid.wpn_svd_s]               = true,
    [clsid.wpn_svu_s]               = true,
    [clsid.wpn_usp45_s]             = true,
    [clsid.wpn_val_s]               = true,
    [clsid.wpn_vintorez_s]          = true,
    [clsid.wpn_walther_s]           = true
}
    return (object and clsid_weapon[object:clsid()])
end
function isWeaponFireOnly(object)
local clsid_weapon_fireonly = {
    [clsid.wpn_ak74_s]              = true,
    [clsid.wpn_bm16_s]              = true,
    [clsid.wpn_fn2000]              = true,
    [clsid.wpn_fort]                = true,
    [clsid.wpn_groza_s]             = true,
    [clsid.wpn_hpsa_s]              = true,
    [clsid.wpn_lr300_s]             = true,
    [clsid.wpn_pm_s]                = true,
    [clsid.wpn_rg6_s]               = true,
    [clsid.wpn_rpg7_s]              = true,
    [clsid.wpn_shotgun_s]           = true,
    [clsid.wpn_svd_s]               = true,
    [clsid.wpn_svu_s]               = true,
    [clsid.wpn_usp45_s]             = true,
    [clsid.wpn_val_s]               = true,
    [clsid.wpn_vintorez_s]          = true,
    [clsid.wpn_walther_s]           = true
}
    return (object and clsid_weapon_fireonly[object:clsid()])
end
IAmAWeapon = {}
function IAmAWeaponInit()
    IAmAWeapon = {
		[clsid.wpn_ak74_s]              = true,
		[clsid.wpn_bm16_s]              = true,
		[clsid.wpn_grenade_f1]          = true,
		[clsid.wpn_grenade_fake]        = true,
		[clsid.wpn_grenade_launcher]    = true,
		[clsid.wpn_grenade_rgd5]        = true,
		[clsid.wpn_grenade_rpg7]        = true,
		[clsid.wpn_groza_s]             = true,
		[clsid.wpn_hpsa_s]              = true,
		[clsid.wpn_knife_s]             = true,
		[clsid.wpn_lr300_s]             = true,
		[clsid.wpn_pm_s]                = true,
		[clsid.wpn_rpg7_s]              = true,
		[clsid.wpn_shotgun_s]           = true,
		[clsid.wpn_svd_s]               = true,
		[clsid.wpn_svu_s]               = true,
		[clsid.wpn_usp45_s]             = true,
		[clsid.wpn_val_s]               = true,
		[clsid.wpn_vintorez_s]          = true,
		[clsid.wpn_walther_s]           = true
    }
end
IAmAWeaponFireOnly = {}
function IAmAWeaponFireOnlyInit()
    IAmAWeaponFireOnly = {
		[clsid.wpn_ak74_s]              = true,
		[clsid.wpn_bm16_s]              = true,
		[clsid.wpn_fn2000]              = true,
		[clsid.wpn_fort]                = true,
		[clsid.wpn_groza_s]             = true,
		[clsid.wpn_hpsa_s]              = true,
		[clsid.wpn_lr300_s]             = true,
		[clsid.wpn_pm_s]                = true,
		[clsid.wpn_rg6_s]               = true,
		[clsid.wpn_rpg7_s]              = true,
		[clsid.wpn_shotgun_s]           = true,
		[clsid.wpn_svd_s]               = true,
		[clsid.wpn_svu_s]               = true,
		[clsid.wpn_usp45_s]             = true,
		[clsid.wpn_val_s]               = true,
		[clsid.wpn_vintorez_s]          = true,
		[clsid.wpn_walther_s]           = true
    }
end

--Tvchislyaet yaw in radians
function yaw( v1, v2 )
    return  math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) )
end

function yaw_degree( v1, v2 )
    return  (math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) ) * 57.2957)
end
function yaw_degree3d( v1, v2 )
    return  (math.acos((v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)/math.sqrt((v1.x*v1.x + v1.y*v1.y + v1.z*v1.z )*(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z)))*57.2957)
end

function vector_cross(v1, v2)
    return vector ():set (v1.y  * v2.z  - v1.z  * v2.y, v1.z  * v2.x  - v1.x  * v2.z, v1.x  * v2.y  - v1.y  * v2.x)
end

--//Vector rotates around the y-axis counterclockwise
function vector_rotate_y(v, angle)
    angle = angle * 0.017453292519943295769236907684886
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

-- cleaning tables
function clear_table(t)
    local table_remove = table.remove
    while #t > 0 do
          table_remove (t, #t)
    end
end

function new_point(center_id, position_id,radius, min_radius)
    local math_random = math.random
    local dir = vector():set(math_random(-1000, 1000)/1000.0, 0.0001, math_random(-1000, 1000)/1000.0)
    local pos = level.vertex_in_direction(center_id, dir, radius)
    local i   = 1
    while(level.vertex_position(position_id):distance_to(level.vertex_position(pos) ) < min_radius and i < 20) do
        dir = vector():set(math_random(-1000, 1000)/1000.0, 0.0001, math_random(-1000, 1000)/1000.0)
        pos = level.vertex_in_direction(center_id, dir, radius)
        i   = i + 1
    end
    return (level.vertex_position(pos))
end

function stop_play_sound(obj)
  if obj:alive() == true then
    obj:set_sound_mask(-1)
    obj:set_sound_mask(0)
  end
end

function object_type(obj)
    local otype = get_clsid(obj)
    local type
    if  otype == clsid.actor or
        otype == clsid.script_stalker or
        otype == clsid.script_trader
    then
        type = "stalker"
    elseif  otype == clsid.crow or
        otype == clsid.zombie or
        otype == clsid.flesh or
        otype == clsid.controller or
        otype == clsid.bloodsucker or
        otype == clsid.burer or
        otype == clsid.fracture or
        otype == clsid.chimera or
        otype == clsid.boar or
        otype == clsid.flesh_group or
        otype == clsid.dog_red or
        otype == clsid.dog_black or
        otype == clsid.cat or
        otype == clsid.pseudo_gigant
    then
        type = "monstr"
    elseif  otype == clsid.wpn_fn2000 or
        otype == clsid.wpn_ak74 or
        otype == clsid.wpn_lr300 or
        otype == clsid.wpn_hpsa or
        otype == clsid.wpn_pm or
        otype == clsid.wpn_fort or
        otype == clsid.wpn_binocular or
        otype == clsid.wpn_shotgun or
        otype == clsid.wpn_svd or
        otype == clsid.wpn_svu or
        otype == clsid.wpn_rpg7 or
        otype == clsid.wpn_val or
        otype == clsid.wpn_vintorez or
        otype == clsid.wpn_walther or
        otype == clsid.wpn_usp45 or
        otype == clsid.wpn_groza or
        otype == clsid.wpn_knife or
        otype == clsid.wpn_scope or
        otype == clsid.wpn_silencer or
        otype == clsid.wpn_grenade_launcher or
        otype == clsid.obj_physic or
        otype == clsid.obj_breakable or
        otype == clsid.device_pda or
        otype == clsid.device_torch or
        otype == clsid.device_detector_simple or
        otype == clsid.obj_bolt or
        otype == clsid.obj_medkit or
        otype == clsid.obj_food or
        otype == clsid.obj_bottle or
        otype == clsid.obj_antirad or
        otype == clsid.obj_explosive or
        otype == clsid.obj_document or
        otype == clsid.obj_attachable or
        otype == clsid.wpn_grenade_f1 or
        otype == clsid.wpn_grenade_rpg7 or
        otype == clsid.wpn_grenade_rgd5 or
        otype == clsid.wpn_grenade_fake or
        otype == clsid.equ_scientific or
        otype == clsid.equ_stalker or
        otype == clsid.equ_military or
        otype == clsid.equ_exo or
        otype == clsid.wpn_ammo or
        otype == clsid.wpn_ammo_vog25 or
        otype == clsid.wpn_ammo_og7b or
        otype == clsid.wpn_ammo_m209
    then
        type = "item"
    else
        type = "none"
    end
    if type == "stalker" or
       type == "monstr" then
        if obj:alive() == false then
            type = "corpse"
        end
    end
    return type
end

--// Is obj monster
function is_object_monster(obj)
	local otype = get_clsid(obj)
	if otype and (otype == clsid.crow
		or otype == clsid.zombie
		or otype == clsid.flesh
		or otype == clsid.controller
		or otype == clsid.bloodsucker
		or otype == clsid.burer
		or otype == clsid.fracture
		or otype == clsid.chimera
		or otype == clsid.boar
		or otype == clsid.dog_red
		or otype == clsid.dog_black
		or otype == clsid.cat
		or otype == clsid.poltergeist
		--or otype == clsid.werewolf_s
		--or otype == clsid.bibliotekar_s
		or otype == clsid.pseudo_gigant) then
		return true
	end
	return false
end

function point_with_bit(patrol_path, bit, old_point)      
  local points = {}                                       
    for i = 0, patrol_path:count()-1 do
      if( patrol_path:flag(i, bit)) then
            if old_point == nil or old_point ~= i then
                table.insert(points, patrol_path:point(i))
            end
        end
    end
    local number_point = #points
    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return points[1]
    else
        return points[math.random(1, number_point)]
    end
end

function point_with_bit_id(patrol_path, bit, old_point)        
    local points = {}                                          
    for i = 0, patrol_path:count()-1 do
      if( patrol_path:flag(i, bit)) then
            if old_point == nil or old_point ~= i then
                table.insert(points, i)
            end
        end
    end
    local number_point = #(points)
    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return patrol_path:level_vertex_id(points[1])
    else
        return patrol_path:level_vertex_id(points[math.random(1, number_point)])
    end
end

function near_point_with_bit(point, patrol_path, bit)
    local new_point = nil
    local index = nil
    local dist = 1000.0
    for i = 0, patrol_path:count()-1 do
        if( patrol_path:flag(i, bit) ) then
            if(new_point == nil or patrol_path:point(i):distance_to(point) < dist) then
                --removed comment by TB3D
                new_point = patrol_path:point(i)
                index = i
                dist = new_point:distance_to(point)
             end
        end
    end
    return index
end

--function print_table(table, subs)	--called by non TB3D scripts in db files, removed 109955
	--show_tables(table, subs, "internal")
--end

function show_tables(table, subs, origin)
	local sub, isfrom
	if subs ~= nil then sub = subs else sub = "" end
	if origin ~= nil then isfrom = origin else isfrom = "unknown" end
	TB3D_Services.packet_alert("_G: print table for["..isfrom.."] SUBS["..sub.."]{")
	local ptype
	for k,v in pairs(table) do
		if k and v then
			ptype = type(v) or nil
			if ptype == nil then ptype = "unknown" end
			if ptype == "table" then
				--TB3D_Services.packet_alert("TBLE["..utils.to_str(k).."]["..utils.to_str(v).."]")
				show_tables(v,sub, "SUBTABLE")
			elseif ptype == "function" then
				--TB3D_Services.packet_alert("FUNC["..utils.to_str(k).."]["..utils.to_str(v).."]")
			elseif ptype == "number" then
				--TB3D_Services.packet_alert("NUMB["..utils.to_str(k).."]["..utils.to_str(v).."]")
			elseif ptype == "string" then
				--TB3D_Services.packet_alert("STRN["..utils.to_str(k).."]["..utils.to_str(v).."]")
			elseif ptype == "userdata" then
				--TB3D_Services.packet_alert("USER["..utils.to_str(k).."]["..utils.to_str(v).."]")
			elseif ptype == "boolean" then
				if v == true then
					TB3D_Services.packet_alert("BOOL["..utils.to_str(k).."][true]")
				else
					TB3D_Services.packet_alert("BOOL["..utils.to_str(k).."][false]")
				end
			else
				TB3D_Services.packet_alert("DATA["..utils.to_str(k).."] unknown type["..utils.to_str(ptype).."] value["..utils.to_str(v).."]") 
			end
		elseif k then
			TB3D_Services.packet_alert("DATA["..utils.to_str(k).."] type[nil]!!!!")
		else
			TB3D_Services.packet_alert("DATA[nil]!!!!")
		end
	end
	TB3D_Services.packet_alert("} table for["..isfrom.."] done")
end

-------------------------------------------------------------------------------------------
function switch_online(id)
    if id == -1 then return end
	local sim = alife ()
	if sim ~= nil then
		--TB3D_Services.packet_alert("_g: switch online["..utils.to_str(id).."]")
	   sim:set_switch_online  (id, true)
	   sim:set_switch_offline (id, false)
	end
end
-------------------------------------------------------------------------------------------
function switch_offline (npc)
    if npc == nil or npc:alive () == false then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (npc:id (), false)
       sim:set_switch_offline (npc:id (), true)
    end
end
-------------------------------------------------------------------------------------------
function get_actor_id()
  if(level.actor() == nil) then return -1 end
  return level.actor():id()
end
-------------------------------------------------------------------------------------------
function IsMonster (object, class_id)
    local id = class_id or get_clsid (object)
	local monsters = {
		[clsid.boar_s] = true,
		[clsid.bloodsucker_s] = true,
		[clsid.dog_s] = true,
		[clsid.flesh_s] = true,
		[clsid.pseudodog_s] = true,
		[clsid.psy_dog_s] = true,
		[clsid.burer_s] = true,
		[clsid.cat_s] = true,
		[clsid.chimera_s] = true,
		[clsid.controller_s] = true,
		[clsid.fracture_s] = true,
		[clsid.poltergeist_s] = true,
		[clsid.gigant_s] = true,
		[clsid.zombie_s] = true,
		[clsid.tushkano_s] = true,
		[clsid.snork_s] = true,
		[clsid.psy_dog_phantom_s] = true--,
		--[clsid.werewolf_s ] = true,
		--[clsid.bibliotekar_s ] = true
	}
	return monsters[id] or false
end
-------------------------------------------------------------------------------------------
function IsStalker (object, class_id)
    local id = class_id or get_clsid (object)
	local Stalkers = {
	 [clsid.actor] = true,
	 [clsid.script_stalker] = true
	}
	return Stalkers[id] or false
end
IAmAStalker = {}
function IAmAStalkerInit()
    IAmAStalker = {
        [clsid.actor] = true,
        [clsid.script_stalker] = true,
		[34] = true
    }
end
IAmAMonster = {}
function IAmAMonsterInit()
    IAmAMonster = {
		[clsid.boar_s] = true,
		[clsid.bloodsucker_s] = true,
		[clsid.dog_s] = true,
		[clsid.flesh_s] = true,
		[clsid.pseudodog_s] = true,
		[clsid.psy_dog_s] = true,
		[clsid.burer_s] = true,
		[clsid.cat_s] = true,
		[clsid.chimera_s] = true,
		[clsid.controller_s] = true,
		[clsid.fracture_s] = true,
		[clsid.poltergeist_s] = true,
		[clsid.gigant_s] = true,
		[clsid.zombie_s] = true,
		[clsid.tushkano_s] = true,
		[clsid.snork_s] = true,
		[clsid.psy_dog_phantom_s] = true,
		[36] = true										--m_trader
		--[clsid.werewolf_s ] = true,
		--[clsid.bibliotekar_s ] = true
    }
end-------------------------------------------------------------------------------------------

function get_section(obj)					--110000
	local sect = ""
	if obj then
		if obj.section_name then sect = obj:section_name() end
		if not sect or sect == "" then
			if obj.section then sect = obj:section() end
		end
--[[
		if not sect then
			if string_find(obj:name(), "physic_destroyable_object") then
				sect = "physic_destroyable_object"
			elseif string_find(obj:name(), "physic_object") then
				sect = "physic_object"
			elseif string_find(obj:name(), "light_galogen") then
				sect = "lights_hanging_lamp"
			elseif string_find(obj:name(), "lights_") then
				sect = "lights_hanging_lamp"
			end
		end
--]]
	end
	return sect
end

level_index = {
["..."] = 0,
["l01_escape"] = 1,
["l02_garbage"] = 2,
["l03_agroprom"] = 3,
["l03u_agr_underground"] = 4,
["l04_darkvalley"] = 5,
["l04u_labx18"] = 6,
["l05_bar"] = 7,
["l06_rostok"] = 8,
["l08_yantar"] = 9,
["l08u_brainlab"] = 10,
["l07_military"] = 11,
["l10_radar"] = 12,
["l11_pripyat"] = 13,
["l12_stancia"] = 14,
["l12u_sarcofag"] = 15,
["l12u_control_monolith"] = 16,
["l12_stancia_2"] = 17,
["l10u_bunker"] = 18,
["atp_for_test22"] = 19,
["peshera"] = 20,
["puzir"] = 21,
["aver"] = 22,
["av_peshera"] = 23,
["limansk"] = 24,
["hospital"] = 25,
["generators"] = 26,
["warlab"] = 27,
["red_forest"] = 28,
["lost_village"] = 29,
["marsh"] = 30,
["dead_city"] = 31,
["zaton"] = 32,
["jupiter"] = 33,
["pripyat"] = 34,
["jupiter_underground"] = 35,
["labx8"] = 36,
["cs_agroprom_underground"] = 37,
["predbannik"] = 38,
["garbage_old"] = 39,
["yantar_old"] = 40,
["swamp_old"] = 41,
["hiding_road"] = 42,
["k01_darkscape"] = 43,
["dark_forest"] = 44,
["level_f-1"] = 45,
["promzone"] = 46,
["deadcity"] = 47,
["l01_krasivay"] = 48,
["l02_dd"] = 49,
["l03_rinok"] = 50,
["l04_pogost"] = 51,
["l05_vokzal"] = 52,
["digger_stash"] = 53,
["lab_x14"] = 54,
["collector22"] = 55,
["l01_poligon"] = 56
}
local level_indx
function get_level_index(lname)			--110004
	if level_indx == nil then
		level_indx = level_index[lname]
		TB3D_Services.packet_alert("_g: level["..lname.."] index["..utils.to_str(level_indx).."]")
	end
	return level_indx
end

function level_object_by_sid( sid )
  local sim = alife()
  if sim then
    local se_obj = sim:story_object( sid )
    if se_obj then
      return level.object_by_id( se_obj.id )
    end
  end
  return nil
end

function id_by_sid( sid )
  local sim = alife()
  if sim then
    local se_obj = sim:story_object( sid )
    if se_obj then
      return se_obj.id
    end
  end
  return nil
end

--function set_postprocess(name_ini_file)
  --bind_stalker.post_process = postprocess.PostProcess(ini_file(name_ini_file))
--end
--function remove_postprocess()
  --bind_stalker.post_process = nil
--end

function set_inactivate_input_time(delta)
  db.set_disable_input_time(db.actor, game.get_game_time())
  db.set_disable_input_idle(db.actor, delta)
  level.disable_input()
end
-- Accepts: position position position to look at sleep time in minutes.
function set_sleep_relocate(point, look, timeout)
  db.set_sleep_rel_time(db.actor, game.get_game_time())
  db.set_sleep_rel_idle(db.actor, timeout*60)
  db.set_sleep_rel_point(db.actor, point)
  db.set_sleep_rel_look(db.actor, look)
  --set_inactivate_input_time(timeout*60)
  --db.actor:actor_sleep(0, timeout)
end

-- checks the integer part is odd
function odd( x )
  return math.floor( x * 0.5 ) * 2 == math.floor( x )
end

--' Fatigue
function on_actor_critical_power()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_11_weakness")
  end
  if not has_alife_info("encyclopedy_tutorial_weakness") then
    db.actor:give_info_portion("encyclopedy_tutorial_weakness")
  end
end

function on_actor_critical_max_power()
end

--' Bleeding
function on_actor_bleeding()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_8_wound")
  end
  if not has_alife_info("encyclopedy_tutorial_wound") then
    db.actor:give_info_portion("encyclopedy_tutorial_wound")
  end
end

function on_actor_satiety()
end

--' Radiation
function on_actor_radiation()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_6_radiation")
  end
  if not has_alife_info("encyclopedy_tutorial_radiation") then
    db.actor:give_info_portion("encyclopedy_tutorial_radiation")
  end
end

--' Jammed weapons
function on_actor_weapon_jammed()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_9_weapon")
  end
  if not has_alife_info("encyclopedy_tutorial_weapon") then
    db.actor:give_info_portion("encyclopedy_tutorial_weapon")
  end
end

--' can not walk because of the weight
function on_actor_cant_walk_weight()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_14_overload")
  end
  if not has_alife_info("encyclopedy_tutorial_overload") then
    db.actor:give_info_portion("encyclopedy_tutorial_overload")
  end
end

--' Psi effects
function on_actor_psy()
end

function set_start_collector()
	start_collector = true
end

function get_texture_info(id_name, id_default)
  if id_default == nil then id_default = id_name end
  local task_info = GetTextureInfo(id_name, id_default)
  local r = task_info:get_rect()
  r.x2 = r.x2 - r.x1
  r.y2 = r.y2 - r.y1
  return task_info:get_file_name(), r
end

-- 				!!!!TB3D   start game callback
function start_game_callback()
	if TB3D_Modders.Global_Debug then TB3D_Services.info_alert("_G: start game callback") end
    IAmAStalkerInit()		--109999
    IAmAMonsterInit()
	IAmAWeaponInit()
	task_manager.clear_task_manager()
	treasure_manager.clear_treasure_manager()
	dialog_manager.fill_phrase_table() 
	amk.on_game_start() --obj)  --AMK UTILS		sets rand seed, ver, start time and cslid lists
	xr_sound.clear_all_sound_object()
	if TB3D_Modders.Global_Debug then TB3D_Services.info_alert("_G: start game callback done") end
end

ammo_section = {}
ammo_section["ammo_9x18_fmj"]		= true
ammo_section["ammo_9x18_pbp"]		= true
ammo_section["ammo_9x18_pmm"]		= true
ammo_section["ammo_9x19_fmj"]		= true
ammo_section["ammo_9x19_pbp"]		= true
ammo_section["ammo_5.45x39_fmj"]	= true
ammo_section["ammo_5.45x39_ap"]		= true
ammo_section["ammo_5.56x45_ss190"]	= true
ammo_section["ammo_5.56x45_ap"]		= true
ammo_section["ammo_5.7x28_fmj"]		= true
ammo_section["ammo_5.7x28_ap"]		= true
ammo_section["ammo_7.62x54_7h1"]	= true
ammo_section["ammo_7.62x54_ap"]		= true
ammo_section["ammo_7.62x54_7h14"]	= true
ammo_section["ammo_9x39_pab9"]		= true
ammo_section["ammo_gauss"]			= true
ammo_section["ammo_super_gauss"]	= true
ammo_section["ammo_9x39_ap"]		= true
ammo_section["ammo_9x39_sp5"]		= true
ammo_section["ammo_11.43x23_fmj"]	= true
ammo_section["ammo_11.43x23_hydro"]	= true
ammo_section["ammo_12x70_buck"]		= true
ammo_section["ammo_12x76_dart"]		= true
ammo_section["ammo_12x76_zhekan"]	= true
ammo_section["ammo_7.62x25_p"]		= true
ammo_section["ammo_7.62x25_ps"]		= true
ammo_section["ammo_7.62x51_fmj"]	= true
ammo_section["ammo_7.62x51_ap"]		= true
ammo_section["ammo_7.62x54r"]		= true
ammo_section["ammo_minigun"]		= true
ammo_section["ammo_5.7x28_ss190"]	= true
ammo_section["ammo_arboltl"]		= true
ammo_section["ammo_igl"]			= true
ammo_section["ammo_7.62x51box"]		= true
ammo_section["ammo_12.7x108"]		= true

quest_section = {}
quest_section["gunslinger_flash"]	= true
quest_section["af_blood_tutorial"]	= true
quest_section["esc_wounded_flash"]	= true
quest_section["quest_case_02"]		= true
quest_section["dar_document1"]		= true
quest_section["dar_document2"]		= true
quest_section["dar_document3"]		= true
quest_section["dar_document4"] 		= true
quest_section["dar_document5"]		= true
quest_section["kruglov_flash"]		= true
quest_section["lab_x16_documents"]	= true
quest_section["good_psy_helmet"]	= true
quest_section["bad_psy_helmet"]		= true
quest_section["decoder"]			= true
quest_section["dynamite"]			= true
quest_section["quest_case_01"]		= true
quest_section["hunters_toz"]		= true
quest_section["bar_ecolog_flash"]	= true
quest_section["bar_tiran_pda"]		= true
quest_section["bar_lucky_pda"]		= true 