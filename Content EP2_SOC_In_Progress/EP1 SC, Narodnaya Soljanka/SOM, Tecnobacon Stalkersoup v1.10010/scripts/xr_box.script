--TB3D 1.0.9.9.7.7 cleanup
function my_ver() return "1.0.9.9.7.7" end

local item_by_community = {}

local mul_by_level = {}
local count_by_level = {}

local ammo_sections = {}

local death_ini = ini_file("misc\\ph_box_generic.ltx")

class "ph_item_box"

function ph_item_box:__init(obj)
	self.obj = obj
	local community_list = { "def_box", "small_box_generic", "small_box_ussr", "small_box_nato", "small_box_army", "small_box_science", "big_box_generic", "big_box_dungeons", "big_box_arsenal"}	
	local n
	local id, value = "", ""
	for k,v in pairs(community_list) do
		-- printf("pl: community = %s",v )
        item_by_community[v] = {}
        if death_ini:section_exist(v) then
			id, value = "", ""
		    n = death_ini:line_count(v)
		    for i=0,n-1 do
			    result, id, value	= death_ini:r_line(v,i,"","")
                item_by_community[v][id] = 100*tonumber(value)
				-- printf("PL : id=%s  value=%s",id, value)
		    end
        end
    end
    local level_name = level.name()
	if not death_ini:section_exist(level_name) then
		level_name = "default"
	end
    local n = death_ini:line_count(level_name)
	local id, value = "", ""
	for i=0,n-1 do
		result, id, value	= death_ini:r_line(level_name,i,"","")
        mul_by_level[id] = tonumber(value)
	end        
    local item_count_section = "item_count_"..TB3D_Services.get_difficulty_num() 	--level.get_game_difficulty()
    local n = death_ini:line_count(item_count_section)
	local t = {}
	local min, max
	for i=0,n-1 do
		t = {}
		min = {}
		max = {}
		result, id, value	= death_ini:r_line(item_count_section,i,"","")
        t = parse_nums(value)
		if t[1] == nil then
            --abort("Error on [death_ini] declaration. Section [%s], line [%s]", item_count_section, tostring(id))
        end
        min = t[1]
        max = t[2]
        if max == nil then
            max = min
        end
        if mul_by_level[id] == nil then
            mul_by_level[id] = 0
        end
        min = tonumber(min) * mul_by_level[id]
        max = tonumber(max) * mul_by_level[id]
        count_by_level[id] = {min = min, max = max}
	end        
	ammo_sections = {}
    local n = death_ini:line_count("ammo_sections")
	local id, value = "", ""
	for i=0,n-1 do
		result, id, value	= death_ini:r_line("ammo_sections",i,"","")
        ammo_sections[id] = true
	end        
end

function ph_item_box:spawn_items()
	local spawn_items = {}
	local ini = self.obj:spawn_ini()
	local community	= utils.cfg_get_string(ini, "drop_box", "community", self.obj, false, "", "def_box")
	if r_items(ini, "drop_box", "items") ~= nil then
		local items = r_items(ini, "drop_box", "items")
		for k,v in pairs(items) do
			create_obligatory_items(self.obj, v.section, v.count)
		end
		return
	end
		--printf(" community = %s", community)
    local spawn_items = item_by_community[community]
	if spawn_items == nil then 
		--printf("xr_box: wrong community -- %s setting default def_box ", community)
		local spawn_items = {}
        local spawn_items = item_by_community["def_box"]
	end
	local number
    for k,v in pairs(spawn_items) do		
		number = math.ceil(math.random(count_by_level[k].min, count_by_level[k].max))
		 create_items(self.obj, k, number, v)			
    end
end	

function create_items(obj, section, number, rnd)
    --printf("create %s of %s", tostring(number), tostring(section))
    if ammo_sections[section] == true then
		if math.random(100) <= rnd	then
			if number > 0 then
				local position = vector():set(0,0,0)
				position.x = obj:position().x + math.random(-30,30)/100
				position.z = obj:position().z + math.random(-30,30)/100
				position.y = obj:position().y + 0.3 --math.random(30,50)/100		--109977
				se_respawn.create_ammo(section,	
					    position,
						obj:level_vertex_id(),	
						obj:game_vertex_id(),
						value_65535,												--109977, invalid obj id so spawned on ground
						number)
			end
		end
    else
		local position = vector():set(0,0,0)
        for i=1,number do
            if math.random(100) <=  rnd then
				position.x = obj:position().x + math.random(-30,30)/100
				position.z = obj:position().z + math.random(-30,30)/100
				position.y = obj:position().y + 0.3 --math.random(30,50)/100		--109977
				alife():create(section,	
					    position,
						obj:level_vertex_id(),	
						obj:game_vertex_id())
			end
        end
    end    
end

function parse_names( s )
    local t = {}
    for name in string.gfind( s, "([%w_%-.\\]+)%p*" ) do
        table.insert( t, name )
    end
    return t
end

function r_items( spawn_ini, section, line)
	if spawn_ini:line_exist( section, line ) then
		local t = parse_names( spawn_ini:r_string( section, line ) )
		local n = table.getn( t )
		local ret_table = {}
		local k = 1
		local item = {}
		local p
		while k <= n do
			item = {}
			item.section = t[k]
			if t[k+1] ~= nil then
				p = tonumber(t[k+1])
				if p then
					item.count = p
					k = k + 2
				else
					item.count = 1
					k = k + 1
				end
			else
				item.count	 = 1
				k = k + 1
			end
			table.insert(ret_table, item)	
		end
		return ret_table
	end
	return nil
end

function create_obligatory_items(obj, item , count)
	local position = vector():set(0,0,0)
	for i = 1,count do
				position.x = obj:position().x + math.random(-30,30)/100
				position.z = obj:position().z + math.random(-30,30)/100
				position.y = obj:position().y + 0.3 --math.random(30,50)/100		--109977
				alife():create(item,	
					    position,
						obj:level_vertex_id(),	
						obj:game_vertex_id())
			end
end