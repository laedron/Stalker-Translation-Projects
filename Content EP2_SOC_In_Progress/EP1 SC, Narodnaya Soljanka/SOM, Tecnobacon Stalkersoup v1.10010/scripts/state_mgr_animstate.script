--TB3D 1.0.9.9.7.0 
function my_ver() return "1.0.9.9.7.0" end

local string_find = string.find

--' Script position in body
--' we are in need of state?
class "eva_state_mgr_animstate" (property_evaluator)
function eva_state_mgr_animstate:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate:evaluate()
	return (state_lib.states[self.st.target_state].animstate == nil) or
		   (state_lib.states[self.st.target_state].animstate == self.st.animstate:state())
end
--' Whether we are engaged
class "eva_state_mgr_animstate_locked" (property_evaluator)
function eva_state_mgr_animstate_locked:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_locked:evaluate()
	return self.st.animstate:state() == "busy"
end

--' Do we need to stand
class "eva_state_mgr_animstate_idle" (property_evaluator)
function eva_state_mgr_animstate_idle:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_idle:evaluate()
	return state_lib.states[self.st.target_state].animstate == "stand"
end
--' Are we
class "eva_state_mgr_animstate_idle_now" (property_evaluator)
function eva_state_mgr_animstate_idle_now:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_idle_now:evaluate()
	return self.st.animstate:state() == "stand"
end

--' Do we really need to sit
class "eva_state_mgr_animstate_sit" (property_evaluator)
function eva_state_mgr_animstate_sit:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_sit:evaluate()
	return state_lib.states[self.st.target_state].animstate == "sit"
end
--' Do we sit
class "eva_state_mgr_animstate_sit_now" (property_evaluator)
function eva_state_mgr_animstate_sit_now:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_sit_now:evaluate()
	return self.st.animstate:state() == "sit"
end

--' Do we really need to sit on his knee
class "eva_state_mgr_animstate_sit_knee" (property_evaluator)
function eva_state_mgr_animstate_sit_knee:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_sit_knee:evaluate()
	return state_lib.states[self.st.target_state].animstate == "sit_knee"
end
--' Do we sit on his knee
class "eva_state_mgr_animstate_sit_knee_now" (property_evaluator)
function eva_state_mgr_animstate_sit_knee_now:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_sit_knee_now:evaluate()
	return self.st.animstate:state() == "sit_knee"
end

--' Do we really need to sit on the pope
class "eva_state_mgr_animstate_sit_ass" (property_evaluator)
function eva_state_mgr_animstate_sit_ass:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_sit_ass:evaluate()
	return state_lib.states[self.st.target_state].animstate == "sit_ass"
end
--' Do we sit by the pope
class "eva_state_mgr_animstate_sit_ass_now" (property_evaluator)
function eva_state_mgr_animstate_sit_ass_now:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_sit_ass_now:evaluate()
	return self.st.animstate:state() == "sit_ass"
end

--' Do we really need to sleep
class "eva_state_mgr_animstate_sleep" (property_evaluator)
function eva_state_mgr_animstate_sleep:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_sleep:evaluate()
	return state_lib.states[self.st.target_state].animstate == "sleep"
end
--' Do we sleep
class "eva_state_mgr_animstate_sleep_now" (property_evaluator)
function eva_state_mgr_animstate_sleep_now:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_sleep_now:evaluate()
	return self.st.animstate:state() == "sleep"
end

--' Do we need to be wounded
class "eva_state_mgr_animstate_wounded" (property_evaluator)
function eva_state_mgr_animstate_wounded:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_wounded:evaluate()
	return state_lib.states[self.st.target_state].animstate == "wounded"
end
--' Injured if we
class "eva_state_mgr_animstate_wounded_now" (property_evaluator)
function eva_state_mgr_animstate_wounded_now:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_wounded_now:evaluate()
	return self.st.animstate:state() == "wounded"
end

--' Do we need to be wounded
class "eva_state_mgr_animstate_wounded_heavy" (property_evaluator)
function eva_state_mgr_animstate_wounded_heavy:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_wounded_heavy:evaluate()
	return state_lib.states[self.st.target_state].animstate == "wounded_heavy"
end
--' Injured if we
class "eva_state_mgr_animstate_wounded_heavy_now" (property_evaluator)
function eva_state_mgr_animstate_wounded_heavy_now:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animstate_wounded_heavy_now:evaluate()
	return self.st.animstate:state() == "wounded_heavy"
end

--' Sit down
class "act_state_mgr_animstate_2sit" (action_base)
function act_state_mgr_animstate_2sit:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animstate_2sit:initialize()
	action_base.initialize(self)
	self.st.animstate:set_state("sit")
end
function act_state_mgr_animstate_2sit:execute()
	action_base.execute(self)
end
function act_state_mgr_animstate_2sit:finalize()
	action_base.finalize(self)
end
--' We sit down on one knee
class "act_state_mgr_animstate_2sit_knee" (action_base)
function act_state_mgr_animstate_2sit_knee:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animstate_2sit_knee:initialize()
	action_base.initialize(self)
	self.st.animstate:set_state("sit_knee")
end
function act_state_mgr_animstate_2sit_knee:execute()
	action_base.execute(self)
end
function act_state_mgr_animstate_2sit_knee:finalize()
	action_base.finalize(self)
end
--' Sit on the ass
class "act_state_mgr_animstate_2sit_ass" (action_base)
function act_state_mgr_animstate_2sit_ass:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animstate_2sit_ass:initialize()
	action_base.initialize(self)
	self.st.animstate:set_state("sit_ass")
end
function act_state_mgr_animstate_2sit_ass:execute()
	action_base.execute(self)
end
function act_state_mgr_animstate_2sit_ass:finalize()
	action_base.finalize(self)
end
--' Get up at Idle
class "act_state_mgr_animstate_2idle" (action_base)
function act_state_mgr_animstate_2idle:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animstate_2idle:initialize()
	action_base.initialize(self)
	self.st.animstate:set_state("stand")
end
function act_state_mgr_animstate_2idle:execute()
	action_base.execute(self)
end
function act_state_mgr_animstate_2idle:finalize()
	action_base.finalize(self)
end
--' Fall asleep
class "act_state_mgr_animstate_2sleep" (action_base)
function act_state_mgr_animstate_2sleep:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animstate_2sleep:initialize()
	action_base.initialize(self)
	self.st.animstate:set_state("sleep")
end
function act_state_mgr_animstate_2sleep:execute()
	action_base.execute(self)
end
function act_state_mgr_animstate_2sleep:finalize()
	action_base.finalize(self)
end
--' Injured
class "act_state_mgr_animstate_2wounded" (action_base)
function act_state_mgr_animstate_2wounded:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animstate_2wounded:initialize()
	action_base.initialize(self)
	self.st.animstate:set_state("wounded")
end
function act_state_mgr_animstate_2wounded:execute()
	action_base.execute(self)
end
function act_state_mgr_animstate_2wounded:finalize()
	action_base.finalize(self)
end
--' Injured severely
class "act_state_mgr_animstate_2wounded_heavy" (action_base)
function act_state_mgr_animstate_2wounded_heavy:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animstate_2wounded_heavy:initialize()
	action_base.initialize(self)
	self.st.animstate:set_state("wounded_heavy")
end
function act_state_mgr_animstate_2wounded_heavy:execute()
	action_base.execute(self)
end
function act_state_mgr_animstate_2wounded_heavy:finalize()
	action_base.finalize(self)
end



--' A class that implements state of the body

class "body_state"
function body_state:__init(npc)
	self.npc = npc
	self.target_state = "stand"
	self.current_state = "stand"

	self.transfer_anim = {
		stand		= { sit			= {nrm = {"idle_0_to_sit_0"}},
						sit_knee	= {nrm = {"idle_0_to_sit_1"}},
						sit_ass		= {nrm = {"idle_0_to_sit_2"}},
						sleep		= {nrm = {"idle_0_to_sit_0","sit_to_sleep_0"}}},

		sit			= { sit_knee	= {nrm = {"sit_idle_0_to_sit_idle_1"}},
						sit_ass		= {nrm = {"sit_idle_0_to_sit_idle_2"}},
						stand		= {nrm = {"sit_0_to_idle_0"},
									   lazy ={"sit_0_lazy_idle_0"}},
						sleep		= {nrm = {"sit_0_to_sleep_0"}}},

		sit_knee	= { sit			= {nrm = {"sit_idle_1_to_sit_idle_0"}},
						sit_ass		= {nrm = {"sit_idle_1_to_sit_idle_2"}},
						stand		= {nrm = {"sit_1_to_idle_0"},
									   lazy ={"sit_1_lazy_idle_0"}},
						sleep		= {nrm = {"sit_idle_1_to_sleep_0"}}},

		sit_ass		= { sit			= {nrm = {"sit_idle_2_to_sit_idle_0"}},
						sit_knee	= {nrm = {"sit_idle_2_to_sit_idle_1"}},
						stand		= {nrm = {"sit_2_to_idle_0"},
									   lazy= {"sit_2_lazy_idle_0"}},
						sleep		= {nrm = {"sit_2_to_sleep_0"}}},
						
		sleep		= {	stand		= {nrm = {"sleep_to_sit_0","sit_0_to_idle_0"},
									   lazy ={"sleep_to_sit_0","sit_0_lazy_idle_0"}},
						sit			= {nrm = {"sleep_0_to_sit_0"}},
						sit_knee	= {nrm = {"sleep_0_to_sit_idle_1"}},
						sit_ass		= {nrm = {"sleep_0_to_sit_2"}}}

	}

	self.idle_anim = {
		sit			= "sit_0_idle_0",
		sit_knee	= "sit_1_idle_0",
		sit_ass		= "sit_2_idle_0",
		sleep		= "sleep_idle_0"
	}

end
--' Checks whether we have completed the change of body position
function body_state:update()
	local is_report = false
	if TB3D_Modders.use_state_message and string_find(self.npc:name(), TB3D_Modders.npc_to_log) then is_report = true end
	if is_report then TB3D_Services.packet_alert("state mgr animation state: body state update["..utils.to_str(self.npc:name()).."] current state["..utils.to_str(self.current_state).."] target state["..utils.to_str(self.target_state).."] start") end
	if self.target_state ~= self.current_state then
		if self.idle_anim[self.target_state] ~= nil then
			if self.npc:animation_count() <= 1 then
				self.current_state = self.target_state
			end
		else
			if self.npc:animation_count() == 0 then
				self.current_state = self.target_state
			end
		end
		if is_report then TB3D_Services.packet_alert("state mgr animation state: body state update["..utils.to_str(self.npc:name()).."]  current state["..utils.to_str(self.current_state).."] target state["..utils.to_str(self.target_state).."] tried change") end
	end
end
--' Returns the current state of the body
function body_state:state()
	--printf("%s",self.current_state)
	return self.current_state
end
--' Installation of the new body position
function body_state:set_state(id)
	--printf("set new target state %s", id)
	
	self.npc:clear_animations()
	if self.transfer_anim[self.current_state] ~= nil and
	   self.transfer_anim[self.current_state][id] ~= nil
	then
		-- Here we check whether we lazy or fast rising
		local astate = self.transfer_anim[self.current_state][id]
		local lazy = astate.lazy ~= nil
		
		if lazy == true and 
		   (self.npc:best_enemy() ~= nil or
		   self.npc:best_danger() ~= nil)
		then
			lazy = false
		end
		
		if lazy == true	then
			for k,v in pairs(astate.lazy) do
				self.npc:add_animation(v, true, false)
			end		
		else
			for k,v in pairs(astate.nrm) do
				self.npc:add_animation(v, true, false)
			end
		end				
	end
	if self.idle_anim[id] ~= nil then
		self.npc:add_animation(self.idle_anim[id], true, false)
	end
	self.current_state = "busy"
	self.target_state = id
end
--' Restoring a looped animation aydlovuyu
function body_state:add_idle_animation()
	if self.idle_anim[self.current_state] ~= nil then
		self.npc:add_animation(self.idle_anim[self.current_state], true, false)
	end
end
--' Are there any current state idlovaya Animation
function body_state:idle_animation_present()
	if self.idle_anim[self.current_state] ~= nil then
		return true
	end
	return false
end



