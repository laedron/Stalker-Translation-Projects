-- TB3D 1.0.9.9.9.8  added old pda sound option, optimized, hit styles, loc give game news, localized, obj level, update
function my_ver() return "1.0.9.9.9.8" end

local math_random = math.random
local translate = game.translate_string

-- function to start the timer when on drope
function timeBombOut(id, sect)
	amk.start_timer("babah_drop_timeBomb", 0.2, {id = id, sect = sect})
end

-- function to start the timer when on drop
function mineOut(id, sect)
	amk.start_timer("babah_drop_mine", 0.2, {id = id, sect = sect})
end

-- function to start the timer when on drop
function detonatorOut(id, sect)
	amk.start_timer("babah_drop_detonator", 0.2, {id = id, sect = sect})
end

local bombs = {
	["sect"] = {
		["bomba"] = {
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		},
		["bomba_small"] = {
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		},
		["bomba_big"] = {
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		}
	},
	["func"] = bombOut
}

local timeBombs = {
	["sect"] = {
		["bomba_timer_n_10"] = {
			["activated"] = "bomba_timer_n_10_activated",
			["base"] = "bomba_timer_n_10_base"
		},
		["bomba_timer_b_10"] = {
			["activated"] = "bomba_timer_b_10_activated",
			["base"] = "bomba_timer_b_10_base"
		},
		["bomba_timer_n_30"] = {
			["activated"] = "bomba_timer_n_30_activated",
			["base"] = "bomba_timer_n_30_base"
		},
		["bomba_timer_b_30"] = {
			["activated"] = "bomba_timer_b_30_activated",
			["base"] = "bomba_timer_b_30_base"
		}
	},
	["func"] = timeBombOut
}

local timeBombsBase = {
	["bomba_timer_n_10_base"] = {
		["inventory"] = "bomba_timer_n_10"
	},
	["bomba_timer_b_10_base"] = {
		["inventory"] = "bomba_timer_b_10"
	},
	["bomba_timer_n_30_base"] = {
		["inventory"] = "bomba_timer_n_30"
	},
	["bomba_timer_b_30_base"] = {
		["inventory"] = "bomba_timer_b_30"
	}
}

local timeBombsActivated = {
	["bomba_timer_n_10_activated"] = {
		["delay"] = 10
	},
	["bomba_timer_n_10_activated"] = {
		["delay"] = 10
	},
	["bomba_timer_n_30_activated"] = {
		["delay"] = 30
	},
	["bomba_timer_b_30_activated"] = {
		["delay"] = 30
	}
}

local mines = {
	["count"] = 0,
	["sect"] = {
		["bomba_mina_n"] = {
			["delay"] = 3,
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		},
		["bomba_mina_b"] = {
			["delay"] = 3,
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		}
	},
	["func"] = mineOut
}

local detonators = {
	["sect"] = {
		["detonator"] = {
			["probability"] = 0.75, -- the probability of successful operation, if no section - 1
			["delay"] = 2, -- delay in seconds, if no section - 0
			["distance"] = 100,
			["id"] = -1,
			["name"] = "NK-32beta RUS",
			["has"] = false,
			["activated"] = false
		},
		["detonator_2"] = {
			["distance"] = 300,
			["id"] = -1,
			["name"] = "NK-37 RUS",
			["has"] = false,
			["activated"] = false
		}
	},
	["func"] = detonatorOut
}

local ignored_items = {
	["device_torch"]	= true,
	["device_pda"]		= true,
	["hand_radio"]		= true,
	["guitar_a"]		= true,
	["harmonica_a"]		= true,
	["binocular_a"]		= true,
	["wpn_knife"]		= true,
	["wpn_binoc"]		= true,
	["bolt"]			= true,
	["player"]			= true
}

local transferredBombs = {}
local explosivesAll

local funcBySect = {}
function collectFuncBySect(t)
	for k,v in pairs(t["sect"]) do
		funcBySect[k] = t["func"]
	end
end

collectFuncBySect(timeBombs)
collectFuncBySect(mines)
--collectFuncBySect(bombs) -- We seek a bomb detonator is triggered only when
collectFuncBySect(detonators)
--amk.dump_table(funcBySect)

function li(ob)
	if ob then
		local id = ob:id()
		local sect = ob:section()
		local f = funcBySect[sect]
		if f then
			f(id, sect)
			return true
		end
	end
	return false
end

function useDetonator(sect)
	--get_console():execute("load ~~~ function useDetonator(sect)")
	if detonators["sect"][sect]["delay"] then
		-- start the timer delays the activation of the detonator
		amk.start_timer("babah_activateDetonator", detonators["sect"][sect]["delay"], sect)
	else
		explodeBombsByDetonator(sect)
	end
end

function explodeBombsByDetonator(sect)
	--get_console():execute("load ~~~ function explodeBombsByDetonator(sect)")
	local actor = db.actor
	local sim = alife()
	if actor == nil or sim == nil then return end
	local detonator = detonators["sect"][sect]
	if detonator then
		local probability = detonator["probability"]
		--get_console():execute("load ~~~ explodeBombsByDetonator(sect) sect: "..sect.." probability: "..tostring(probability))
		if probability then
			if math_random() > probability then
				news_manager.amk_send_tip(translate("sms_babah_error"), translate(detonator["name"]), 1, 15, "common_channel")
				return
			end
		end
		local levelName = TB3D_Services.get_obj_level(actor.m_game_vertex_id)
		if levelName ~= "" then
			local level_object_by_id = level.object_by_id
			local radius = detonator["distance"]
			local anyBombsExploded = false
			local actorPos = actor:position()
			local invBoxExploded
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1")
			collectExplosivesAll()
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.2")
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.3")
			explosivesOnLevel = explosivesAll["online"]["onLevelsInInventory"][levelName]
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.4")
			--get_console():execute("load ~~~ onLevelsInInventory "..levelName.." =")
			if explosivesOnLevel then
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.5")
				--amk.dump_table(explosivesOnLevel)
				for invBoxId, invBoxExplosives in pairs(explosivesOnLevel) do
					--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.6")
					if invBoxId ~= 0 then -- does not undermine in his backpack
						invBox = level_object_by_id(invBoxId)
						if invBox and invBox:position():distance_to(actorPos) <= radius then
							--local isInventoryBox = (invBox:clsid() == clsid.inventory_box)
							--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.7")
							invBoxExploded = false
							for explSect, explIds in pairs(invBoxExplosives) do -- You can cut off the sections
								--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.8")
								if bombs["sect"][explSect] and explIds then
									for j = #explIds, 1, -1 do
										if explIds[j] then
											explosive = level_object_by_id(explIds[j])
											table.remove(explIds, j)
											if explosive then
												--[[if isInventoryBox then
												end]]
												--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.9")
												explode_r(explosive)
												anyBombsExploded = true
												invBoxExploded = true
												break
											end
										end
									end
									if invBoxExploded then
										explosivesOnLevel[invBoxId] = nil
										break
									end
								end
							end
						end
					end
				end
			end
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 2")
			explosivesOnLevel = explosivesAll["online"]["onLevels"][levelName]
			--get_console():execute("load ~~~ onLevels "..levelName.." =")
			if explosivesOnLevel then
				--amk.dump_table(explosivesOnLevel)
				--get_console():execute("load ~~~ explosivesAll:")
				--amk.dump_table(explosivesAll)
				for explSect, explIds in pairs(explosivesOnLevel) do -- You can cut off the sections
					if bombs["sect"][explSect] and explIds then
						for j = #explIds, 1, -1 do
							if explIds[j] then 
								explosive = level_object_by_id(explIds[j])
								if explosive and explosive:position():distance_to(actorPos) <= radius then
									table.remove(explIds, j)
									explode_r(explosive)
									anyBombsExploded = true
									break
								end
							end
						end
					end
				end
				--get_console():execute("load ~~~ explosivesAll:")
				--amk.dump_table(explosivesAll)
			end
			if anyBombsExploded then
				news_manager.amk_send_tip(translate("sms_babah_boom"), translate(detonator["name"]), 1, 15, "common_channel")
			else
				news_manager.amk_send_tip(translate("sms_babah_dud"), translate(detonator["name"]), 1, 15, "common_channel")
			end
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 3")
		end
	end
end

function dropMine(tbl)
	--get_console():execute("load ~~~ function dropMine(tbl)")
	-- start the timer activated mines
	amk.start_timer("babah_activateMine", mines["sect"][tbl.sect]["delay"], tbl)
end

function dropTimeBomb(tbl)
	--get_console():execute("load ~~~ function dropTimeBomb(tbl)")
	--amk.start_timer("babah_timeBomb_activated", timeBombs["sect"][get_section(se_obj)]["delay"], se_obj.id)
	-- convert inventory bomb in the usual
	if timeBombs["sect"][tbl.sect] then
		local obj = level.object_by_id(tbl.id)
		if obj then
			local sim = alife()
			local actor = db.actor
			local sect = timeBombs["sect"][tbl.sect]["base"]
			local pos = obj:position()
			local lv = obj:level_vertex_id()
			local gv = obj:game_vertex_id()
			if not game_graph():valid_vertex_id(gv) then
				gv = actor:game_vertex_id()
				if not game_graph():valid_vertex_id(gv) then -- it seems that no number of vertex
					news_manager.amk_send_tip(translate("sms_babah_strange"), translate("sms_lan"), 1, 15, "common_channel")
					return
				end
			end
			sim:release(sim:object(tbl.id), true)
			sim:create(sect, pos, lv, gv)
		end
	end
end

function relocateTimeBomb(tbl)
	--get_console():execute("load ~~~ function relocateTimeBomb(tbl)")
	--amk.start_timer("babah_timeBomb_activated", timeBombs["sect"][get_section(se_obj)]["delay"], se_obj.id)
	-- transform conventional bombs in the inventory
	if transferredBombs[tbl.id] then
		transferredBombs[tbl.id] = nil
	elseif timeBombs["sect"][tbl.sect] then -- shifted from their inventory
		local sim = alife()
		local obj = level.object_by_id(tbl.id)
		local se_obj = sim:object(tbl.id)
		if obj and se_obj then
			local parent = obj:parent()
			local se_parent = sim:object(se_obj.parent_id)
			if parent then
				--news_manager.amk_send_tip("relocateTimeBomb "..tbl.id.." "..tbl.sect.." "..obj:id().." "..obj:section().." "..obj:name().." parent "..parent:id().." "..parent:section().." "..parent:name())
				--news_manager.amk_send_tip("relocateTimeBomb "..tbl.id.." "..tbl.sect.." "..se_obj.id.." "..get_section(se_obj).." "..se_obj:name().." parent "..se_parent.id.." "..get_section(se_parent).." "..se_parent:name())
				local sect = timeBombs["sect"][tbl.sect]["base"]
				local pos = se_parent.position
				local lv = se_parent.m_level_vertex_id
				local gv = se_parent.m_game_vertex_id
				if not game_graph():valid_vertex_id(gv) then
					gv = db.actor:game_vertex_id()
					if not game_graph():valid_vertex_id(gv) then -- it seems that no number of vertex
						news_manager.amk_send_tip(translate("sms_babah_strange"), translate("sms_lan"), 1, 15, "common_channel")
						return
					end
				end
				local parent_id = se_parent.id
				sim:release(se_obj, true)
				local new_se_obj = sim:create(sect, pos, lv, gv, parent_id)
				if parent:clsid() == clsid.inventory_box then
					-- boxes altogether ohreneli
					--news_manager.amk_send_tip("boxes altogether ohreneli")
					amk.start_timer("babah_timeBomb_transfer", 0.2, new_se_obj.id)
				end
				inventory.on_inventory_info("ui_inventory_hide")
				inventory.on_inventory_info("ui_inventory")
			end
		end
	end
end

function transferTimeBomb(id)
	--get_console():execute("load ~~~ function transferTimeBomb(id)")
	local obj = level.object_by_id(id)
	if obj and db.actor then
		local invBox = obj:parent()
		if invBox then
			transferredBombs[id] = true
			invBox:transfer_item(obj, db.actor)
			db.actor:transfer_item(obj, invBox)
			inventory.on_inventory_info("ui_inventory_hide")
			inventory.on_inventory_info("ui_inventory")
			--news_manager.amk_send_tip(translate("transferTimeBomb(id)")
		end
	end
end

function on_item_take(obj)
	--get_console():execute("load ~~~ function on_item_take(obj)")
	-- transform conventional bombs in the inventory
	local id = obj:id()
	if transferredBombs[id] then
		transferredBombs[id] = nil
	elseif obj then
		local sect = obj:section()
		local timeBombBase = timeBombsBase[sect]
		if timeBombBase then -- shifted in their inventory a bomb with a timer
			local sim = alife()
			local parent = obj:parent()
			if parent then
				local newSect = timeBombBase["inventory"]
				local pos = parent:position()
				local lv = parent:level_vertex_id()
				local gv = parent:game_vertex_id()
				if not game_graph():valid_vertex_id(gv) then
					gv = db.actor:game_vertex_id()
					if not game_graph():valid_vertex_id(gv) then -- it seems that no number of vertex
						news_manager.amk_send_tip(translate("sms_babah_strange"), translate("sms_lan"), 1, 15, "common_channel")
						return
					end
				end
				local parent_id = parent:id()
				sim:release(sim:object(id), true)
				sim:create(newSect, pos, lv, gv, parent_id)
			end
		end
	end
end

function useTimeBomb(tbl)
	--get_console():execute("load ~~~ function useTimeBomb(tbl)")
	if transferredBombs[tbl.id] then
		transferredBombs[tbl.id] = nil
	elseif db.actor then
		local actor = db.actor
		local newSect = timeBombs["sect"][tbl.sect]["activated"]
		local delay = timeBombsActivated[newSect]["delay"]
		local pos = actor:position()
		local lv = actor:level_vertex_id()
		local gv = actor:game_vertex_id()
		if not game_graph():valid_vertex_id(gv) then -- it seems that no number of vertex
					news_manager.amk_send_tip(translate("sms_babah_strange"), translate("sms_lan"), 1, 15, "common_channel")
			return
		end
		se_obj = alife():create(newSect, pos, lv, gv, actor:id())
		amk.start_timer("babah_timeBomb_activated", delay, se_obj.id)
		news_manager.amk_send_tip(translate("sms_babah_timer"), translate("sms_babah"), 1, 15, "common_channel")
	end
end

function explosiveExplode(id)
	--get_console():execute("load ~~~ function explosiveExplode(id)")
	--news_manager.amk_send_tip(translate("trying to blow up")
	local sim = alife()
	local level_object_by_id = level.object_by_id
	local se_obj = sim:object(id)
	if se_obj then
		local obj = level_object_by_id(id)
		if obj then
			-- check that the explosives someone picked up
			if se_obj.parent_id and se_obj.parent_id ~= expendable_object then
				-- move it to the owner
				local sect = obj:section()
				local parent = level_object_by_id(se_obj.parent_id)
				if parent then
					if parent:clsid() == clsid.inventory_box then
						collectExplosivesAll()
						explode_r(obj)
					else
						local pos = parent:position()
						local lv = parent:level_vertex_id()
						local gv = parent:game_vertex_id()
						if not game_graph():valid_vertex_id(gv) then -- it seems that no number of vertex
						news_manager.amk_send_tip(translate("sms_babah_strange"), translate("sms_lan"), 1, 15, "common_channel")
							return
						end
						sim:release(se_obj, true)
						se_obj = sim:create(sect, pos, lv, gv, parent:id())
						amk.start_timer("babah_explode_moved_timeBomb", 0.2, se_obj.id)
						--news_manager.amk_send_tip(translate("Explosives moved "..type(se_obj.id).." "..tostring(se_obj.id))
					end
				end
			else
				collectExplosivesAll()
				explode_r(obj)
				news_manager.amk_send_tip(translate("sms_babah_boom"), translate("sms_lan"), 1, 15, "common_channel")
			end
		else -- object to another location or Offline
			collectExplosivesAll()
			explodeOffline(se_obj, true)
		end
	end
end

function collectExplosivesAll()
	--get_console():execute("load ~~~ function collectExplosivesAll()")
	-- collect information about explosives
	explosivesAll = {
		["online"] = {
			["onLevels"] = {},
			["onLevelsInInventory"] = {},
		},
		["offline"] = {
			["onLevels"] = {},
			["onLevelsInInventory"] = {},
		},
		--["ids"] = {},
		--["count"] = 0
	}
	local explOnlineOnLevels = explosivesAll["online"]["onLevels"]
	local explOnlineOnLevelsInInventory = explosivesAll["online"]["onLevelsInInventory"]
	local explOfflineOnLevels = explosivesAll["offline"]["onLevels"]
	local explOfflineOnLevelsInInventory = explosivesAll["offline"]["onLevelsInInventory"]
	local sim = alife()
	local ggraph = game_graph()
	local level_object_by_id = level.object_by_id
	local levelName
	local correct
	local parent_id
	local obj
	local explTmp
	local t
	local sect
	for i = first_object, last_object do
		se_obj = sim:object(i)
		if se_obj and se_obj:clsid() == clsid.obj_explosive then
			sect = get_section(se_obj)
			correct = false
			parent_id = se_obj.parent_id
			if parent_id and parent_id ~= expendable_object then
				-- the collection of inventory
				p_obj = sim:object(parent_id)
				if p_obj then
					levelName = TB3D_Services.get_obj_level(p_obj.m_game_vertex_id)
					if levelName ~= "" then
						obj = level_object_by_id(parent_id)
						if obj then
							explTmp = explOnlineOnLevelsInInventory
						else
							explTmp = explOfflineOnLevelsInInventory
						end
						if not explTmp[levelName] then
							explTmp[levelName] = {}
						end
						if not explTmp[levelName][parent_id] then
							explTmp[levelName][parent_id] = {}
						end
						if not explTmp[levelName][parent_id][sect] then
							explTmp[levelName][parent_id][sect] = {}
						end
						t = explTmp[levelName][parent_id][sect]
						table.insert(t, i)
						correct = true
						--get_console():execute("load ~~~ collectExplosivesAll(): "..se_obj.id.." name - "..se_obj:name().." sect - "..get_section(se_obj)..", parent_id - "..tostring(se_obj.parent_id))
					end
				end
			else
				levelName = TB3D_Services.get_obj_level(se_obj.m_game_vertex_id)
				if levelName ~= "" then
					obj = level_object_by_id(i)
					if obj then
						explTmp = explOnlineOnLevels
					else
						explTmp = explOfflineOnLevels
					end
					if not explTmp[levelName] then
						explTmp[levelName] = {}
					end
					if not explTmp[levelName][sect] then
						explTmp[levelName][sect] = {}
					end
					t = explTmp[levelName][sect]
					table.insert(t, i)
					correct = true
				end
			end
			if correct then
				-- the overall collection
				--t = explosivesAll["ids"]
				--table.insert(t, i)
				--explosivesAll["count"] = explosivesAll["count"] + 1
			else
				if TB3D_Modders.Global_Debug then TB3D_Services.info_alert("BABAH: FAILED collectExplosivesAll(): ["..se_obj.id.."] sect - ["..get_section(se_obj).."] parent_id - ["..tostring(se_obj.parent_id).."]") end 
			end
		end
	end
	--get_console():execute("load ~~~ collectExplosivesAll():")
	--amk.dump_table(explosivesAll)
end

function explodeMovedTimeBomb(id)
	--get_console():execute("load ~~~ function explodeMovedTimeBomb(id)")
	--news_manager.amk_send_tip(translate("Explosives detonated id "..type(id).." "..tostring(id))
	local se_obj = alife():object(id)
	--news_manager.amk_send_tip(translate("Explosives detonated se_obj.id "..type(se_obj.id).." "..tostring(se_obj.id).." section: "..get_section(se_obj), nil, 3)
	local obj = level.object_by_id(se_obj.id)
	--news_manager.amk_send_tip(translate("Explosives detonated obj "..type(obj), nil, 4)
	--news_manager.amk_send_tip(translate("Explosives detonated obj.id "..type(obj:id()).." "..tostring(obj:id()), nil, 4)
	if obj and se_obj then
		collectExplosivesAll()
		explode_r(obj)
	end
end

local itemsTransferBack = {}

function explode_r(ob)
	--get_console():execute("load ~~~ function explode_r(ob)")
	if ob then
		hitExplosive(ob)
		--collectExplosivesAll()
		local level_object_by_id = level.object_by_id
		local obj = ob
		local parent_id
		if ob:parent() then
			parent_id = ob:parent():id()
			if parent_id and parent_id ~= expendable_object then
				obj = level_object_by_id(parent_id) -- obtain the object owner
			end
		end
		local id = ob:id()
		local pos = obj:position()
		local sect = ob:section()
		local sim = alife()
		local ggraph = game_graph()
		if obj:id() ~= id then -- explosives in the inventory
			if obj.character_community and obj:character_community() == "trader" then -- to avoid shaking the traders
				return
			end
			--if obj:clsid() == clsid.inventory_box then
				pos.y = pos.y + 0.5
			--end
			local lv = obj:level_vertex_id()
			local gv = obj:game_vertex_id()
			if not game_graph():valid_vertex_id(gv) then -- it seems that no number of vertex
					news_manager.amk_send_tip(translate("sms_babah_strange"), translate("sms_lan"), 1, 15, "common_channel")
				return
			end
			--get_console():execute("load ~~~ babah pos: x "..pos.x..", y "..pos.y..", z "..pos.z..", lv "..lv..", gv "..gv)
			-- remove all of the inventory
			--news_manager.amk_send_tip(translate("remove all of the inventory")
			local isNPC = IAmAStalker[obj:clsid()] or IAmAMonster[obj:clsid()]
			if isNPC then
				particles_object("anomaly2\\body_tear_01"):play_at_pos(pos)
			end
			itemsTransferBack = {}
			if isNPC and obj:alive() then
				obj:iterate_inventory(
					function(dummy,item)
						if item:id() ~= id and not ignored_items[item:section()] then
							obj:drop_item(item)
							--sim:create(item:section(), pos, lv, gv)
							--sim:release(sim:object(item:id()))
						end
					end,
					obj
				)
			else -- for caches and corpses
				if db.actor then
					local packet
					local sect
					local items = {}
					local inv_obj
					for i = first_object, last_object do
						if i ~= id then
							se_obj = sim:object(i)
							if se_obj and se_obj.parent_id == parent_id then
								--news_manager.amk_send_tip(translate("babah (se_obj.parent_id == parent_id): id "..se_obj.id..", name "..se_obj:name())
								--get_console():execute("load ~~~ babah (se_obj.parent_id == parent_id): id "..se_obj.id..", name "..se_obj:name()..", online "..tostring(se_obj.online))
								inv_obj = level_object_by_id(se_obj.id)
								if inv_obj then
									--news_manager.amk_send_tip(translate("babah (inv_obj:parent():id() == parent_id): id "..inv_obj:id()..", name "..inv_obj:name())
									--get_console():execute("load ~~~ babah (inv_obj:parent():id() == parent_id): id "..inv_obj:id()..", name "..inv_obj:name())
									if isNPC then
										obj:drop_item(inv_obj)
									else
										if se_obj.online then
											sect = inv_obj:section()
											if timeBombs["sect"][sect] or timeBombsActivated[sect] or timeBombsBase[sect] then
												transferredBombs[i] = true
											end
											obj:transfer_item(inv_obj, db.actor)
											-- collecting items for the next transfer back to the cache, or - crash if some of the items fit into an empty slot weapons and HS has no currently active object in the hands of
											table.insert(itemsTransferBack, se_obj.id)
											-- triggered by a timer
											--[[db.actor:transfer_item(inv_obj, obj)
											packet = net_packet() -- Create an empty package
											se_obj:STATE_Write(packet) -- uploaded to our server packages the state of the object
											-- Using class methods net_packet change the values ??we need.
											sim:release(se_obj, true)
											se_obj = sim:create(sect, pos, lv, gv)
											se_obj:STATE_Read(packet, packet:w_tell()) -- recorded in an altered state of the object back, simulating the process of uploading]]
										end
									end
								else
									news_manager.amk_send_tip(translate("sms_babah_nil")..se_obj.id..translate("sms_babah_name")..se_obj:name())
									--get_console():execute("load ~~~ function explode_r(ob) - babah obj == nil: id "..se_obj.id..", name "..se_obj:name())
								end
							end
						end
					end
				end
			end
			if #itemsTransferBack > 0 then
				amk.start_timer("babah_transfer_items", 0.1, {invId = obj:id(), explId = id, itemsTransferBack = itemsTransferBack})
			else
				local levelName = TB3D_Services.get_obj_level(obj.m_game_vertex_id)
				if levelName ~= "" then
					hitExplosive(ob)
					amk.start_timer("babah_explode_biside_explosives", 0.5, {id = id, sect = sect, x = pos.x, y = pos.y - 0.5, z = pos.z, lvl = levelName})
				end
			end
		else
			local levelName = TB3D_Services.get_obj_level(obj.m_game_vertex_id)
			if levelName ~= "" then
				hitExplosive(ob)
				amk.start_timer("babah_explode_biside_explosives", 0.5, {id = id, sect = sect, x = pos.x, y = pos.y - 0.5, z = pos.z, lvl = levelName})
			end
		end
	else
		news_manager.amk_send_tip(translate("sms_babah_not_explode"), translate("sms_babah"), 1, 10, "common_channel")
	end
end

function itemsTransferBackToInventory(tbl)
	local level_object_by_id = level.object_by_id
	local inventory = level_object_by_id(tbl.invId)
	if inventory then
		local pos = inventory:position()
		pos.y = pos.y + 0.5
		local lv = inventory:level_vertex_id()
		local gv = inventory:game_vertex_id()
		if not game_graph():valid_vertex_id(gv) then -- it seems that no number of vertex
			news_manager.amk_send_tip(translate("sms_babah_another"), translate("sms_lan"), 1, 10, "common_channel")
			return
		end
		local sim = alife()
		local obj, se_obj
		local packet
		local sect
		for i = 1, #tbl.itemsTransferBack do
			obj = level_object_by_id(tbl.itemsTransferBack[i])
			se_obj = sim:object(tbl.itemsTransferBack[i])
			if obj and se_obj and obj:parent() and obj:parent():id() == 0 then
				sect = obj:section()
				db.actor:transfer_item(obj, inventory)
				packet = net_packet() -- Create an empty package
				se_obj:STATE_Write(packet) -- uploaded to our server packages the state of the object
				-- Using class methods net_packet change the values ??we need.
				sim:release(se_obj, true)
				se_obj = sim:create(sect, pos, lv, gv)
				se_obj:STATE_Read(packet, packet:w_tell()) -- recorded in an altered state of the object back, simulating the process of uploading
			end
		end
		itemsTransferBack = {}
		local explosive = level_object_by_id(tbl.explId)
		if explosive then
			hitExplosive(explosive)
		end
		local levelName = TB3D_Services.get_obj_level(inventory.m_game_vertex_id)
		if levelName then
			amk.start_timer("babah_explode_biside_explosives", 0.5, {id = explosive:id(), sect = explosive:section(), x = pos.x, y = pos.y - 0.5, z = pos.z, lvl = levelName})
		end
	else
		if TB3D_Modders.Global_Debug then TB3D_Services.info_alert("BABAH: function itemsTransferBackToInventory(tbl) - inventory == nil: id "..tostring(tbl.invId)) end
	end
end

function explodeBisideExplosives(tbl)
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl)")
	--news_manager.amk_send_tip(translate("Blow up the explosives near")
	local sim = alife()
	local ggraph = game_graph()
	local level_object_by_id = level.object_by_id
	local explosivesOnLevel
	local explosive
	local explId = tbl.id
	local levelNameExplosive = tbl.lvl
	local explPos = vector():set(tbl.x, tbl.y, tbl.z)
	local infoExplosive = collectExplosiveInfo(tbl.sect)
	--amk.dump_table(infoExplosive)
	local radius = infoExplosive["blast_r"]
	--if infoExplosive["frags"] > 0 then
	--	radius = math.max(radius, infoExplosive["frags_r"]) -- too far take out splinters
	--end
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 1")
		-- undermine the explosives near
	--get_console():execute("load ~~~ explosivesAll:")
	--amk.dump_table(explosivesAll)
	local invBox
	local invBoxExploded
	explosivesOnLevel = explosivesAll["online"]["onLevelsInInventory"][levelNameExplosive]
	--get_console():execute("load ~~~ onLevelsInInventory "..levelNameExplosive.." =")
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 2")
	if explosivesOnLevel then
		--amk.dump_table(explosivesOnLevel)
		for invBoxId, invBoxExplosives in pairs(explosivesOnLevel) do
		--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 3")
			invBox = level_object_by_id(invBoxId)
			invBoxExploded = false
			if invBox and invBox:position():distance_to(explPos) <= radius then
				for sect, explIds in pairs(invBoxExplosives) do -- You can cut off the sections
					if explIds then
						for j = #explIds, 1, -1  do -- but here it is possible and with the objects in your inventory to do something, if they remember with explosives in front of this
							if explIds[j] then
								if explIds[j] ~= explId then
									explosive = level_object_by_id(explIds[j])
									table.remove(explIds, j)
									if explosive then
										invBoxExploded = true
										explode_r(explosive)
										break
									end
								else
									table.remove(explIds, j)
								end
							end
						end
					end
					if invBoxExploded then
						explosivesOnLevel[invBoxId] = nil
						break
					end
				end
			end
		end
	end
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 4")
	explosivesOnLevel = explosivesAll["online"]["onLevels"][levelNameExplosive]
	--get_console():execute("load ~~~ onLevels "..levelNameExplosive.." =")
	if explosivesOnLevel then
		--amk.dump_table(explosivesOnLevel)
		--get_console():execute("load ~~~ explosivesAll:")
		--amk.dump_table(explosivesAll)
		for sect, explIds in pairs(explosivesOnLevel) do -- You can cut off the sections
			--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 5")
			if explIds then
				for j = #explIds, 1, -1 do
					if explIds[j] then 
						if explIds[j] ~= explId then
							explosive = level_object_by_id(explIds[j])
							if explosive and explosive:position():distance_to(explPos) <= radius then
								table.remove(explIds, j)
								explode_r(explosive)
							end
						else
							table.remove(explIds, j)
						end
					end
				end
			end
		end
		--get_console():execute("load ~~~ explosivesAll:")
		--amk.dump_table(explosivesAll)
	end
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) finish")
end

function hitExplosive(ob)
	--get_console():execute("load ~~~ function hitExplosive(ob)")
	if ob and TB3D_Modders.default_hit == true then TB3D_hit_styles.burn(ob, ob, 1000, 0, vector():set(0,0,0)) end
		--news_manager.amk_send_tip(translate("Inflict damage to explosives: id "..ob:id()..", name "..ob:name())
end

function collectBombs()
	local sim = alife()
	local se_obj, sect
	for i = first_object, last_object do
		se_obj = sim:object(i)
		if se_obj and se_obj.parent_id == expendable_object then -- lying on the ground
			sect = get_section(se_obj)
			if mines["sect"][sect] then
				addMine(se_obj)
			end
		end
	end
	--amk.dump_table(mines["sect"]) 
end

function addMine(se_obj)
	if se_obj then
		local sect = get_section(se_obj)
		local mine = mines["sect"][sect]
		if mine then
			local sim = alife()
			local ggraph = game_graph()
			local levelName
			local correct = false
			local parent_id = se_obj.parent_id
			if parent_id == expendable_object then
				-- the collection at the levels
				levelName = TB3D_Services.get_obj_level(se_obj.m_game_vertex_id)
				if levelName ~= "" then
					if not mine["onLevels"][levelName] then
						mine["onLevels"][levelName] = {}
					end
					local t = mine["onLevels"][levelName]
					table.insert(t, se_obj.id)
					correct = true
				end
			end
			if correct then
				-- the overall collection
				local t = mine["ids"]
				table.insert(t, se_obj.id)
				mines["count"] = mines["count"] + 1
			else
				if TB3D_Modders.Global_Debug then TB3D_Services.info_alert("BABAH: FAILED addMine(): "..se_obj.id.." sect - "..sect..", parent_id - "..tostring(se_obj.parent_id)) end
			end
		end
	end
		--get_console():execute("load ~~~ addMine+")
		--amk.dump_table(mines)
		--get_console():execute("load ~~~ addMine-")
end

function update(delta)
	if mines["count"] > 0 then
		local npcOnline = db.storage
		local npcOffline = amk_offline_alife.off_npcs
		if npcOnline and npcOffline then
			local npcObj, mineObj
			local level_object_by_id = level.object_by_id
			local onLevels, inInventory, ids
			local mineId, parentId
			local minePos
			local sim = alife()
			local found = false
			local levelOfflineData, offlineNPCs
			local ggraph = game_graph()
			local actorlevelName = level.name() --TB3D_Services.get_obj_level(db.actor.m_game_vertex_id)
			if actorlevelName ~= "" then
				-- check the distance between the mines and online NPCs
				--get_console():execute("load ~~~ MINES+")
				--amk.dump_table(mines)
				--get_console():execute("load ~~~ MINES-")
				for k,v in pairs(mines["sect"]) do
					onLevels = v["onLevels"]
					for levelName, levelData in pairs(onLevels) do
						if levelData then
							for i = #levelData, 1, -1 do
								mineId = levelData[i]
								if mineId then
									mineObj = sim:object(mineId)
									if mineObj then
										parentId = mineObj.parent_id
										-- if someone picked up mine (a clever guy:))
										if parentId and parentId ~= expendable_object then
											-- move mine to the list of inventory and not blow up
											inInventory = v["inInventory"]
											table.insert(inInventory, mineId)
											table.remove(levelData, i)
										else
											minePos = mineObj.position
											-- Search online
											if actorLevelName == levelName then
												for npcId, npc in pairs(npcOnline) do
													npcObj = level_object_by_id(npcId)
													if npcObj and (IAmAStalker[npcObj:clsid()] or IAmAMonster[npcObj:clsid()]) and npcObj:alive() and npcObj:position():distance_to(minePos) <= 1 then
														found = true
														break
													end
												end
											end
											-- Search Offline
											levelOfflineData = npcOffline[levelName]
											if levelOfflineData then
												--get_console():execute("load ~~~ levelOfflineData-")
												--amk.dump_table(levelOfflineData["monsters"])
												--amk.dump_table(levelOfflineData["stalkers"])
												--get_console():execute("load ~~~ levelOfflineData-")
												if not found then
													offlineNPCs = levelOfflineData["monsters"]
													if offlineNPCs then
														for j = 1, #offlineNPCs do
															if offlineNPCs[j]["id"] then
																npcObj = sim:object(offlineNPCs[j]["id"])
																if npcObj and npcObj:alive() and npcObj.position:distance_to(minePos) <= 1 then
																	found = true
																	break
																end
															end
														end
													end
												end
												if not found then
													offlineNPCs = levelOfflineData["stalkers"]
													if offlineNPCs then
														for j = 1, #offlineNPCs do
															if offlineNPCs[j]["id"] then
																npcObj = sim:object(offlineNPCs[j]["id"])
																if npcObj and npcObj:alive() and npcObj.position:distance_to(minePos) <= 1 then
																	found = true
																	break
																end
															end
														end
													end
												end
											end
											if found then
												-- remove mines from the table
												--get_console():execute("load ~~~ MINES babah: "..mineId)
												--amk.dump_table(mines)
												--get_console():execute("load ~~~ MINES babah+")
												table.remove(levelData, i)
												ids = v["ids"]
												for j = #ids, 1, -1 do
													if ids[j] == mineId then
														table.remove(ids, j)
														break
													end
												end
												mines["count"] = mines["count"] - 1
												found = false
												--amk.dump_table(mines)
												--get_console():execute("load ~~~ MINES babah-")
												-- fire a mine
												explosiveExplode(mineId)
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

-- undermining Offline
function explodeOffline(se_obj, first)
	--news_manager.amk_send_tip(translate("trying to blow up the other locations")
	if se_obj then
		local infoExplosive = collectExplosiveInfo(get_section(se_obj))
		--amk.dump_table(infoExplosive)
		local radius = infoExplosive["blast_r"]
		if infoExplosive["frags"] > 0 then
			radius = math.max(radius, infoExplosive["frags_r"])
		end
		local sim = alife()
		local obj = se_obj
		local parent_id = se_obj.parent_id
		if parent_id and parent_id ~= 0 and parent_id ~= expendable_object then
			obj = sim:object(parent_id) -- obtain the object owner
		end
		local levelNameExplosive = TB3D_Services.get_obj_level(obj.m_game_vertex_id)
		if levelNameExplosive ~= "" then
			local infoVictimsOffline = collectExplosiveVictimsOffline(obj, radius)
			--amk.dump_table(infoVictimsOffline)
			damageVictimsOffline(infoVictimsOffline, infoExplosive)
			if first then
				--local packet
				local explosivesOnLevel
				local explosive
				local explId = se_obj.id
				local explPos = obj.position
				-- explosives fulfilled
				sim:release(se_obj, true)
				-- undermine the explosives near
				--amk.dump_table(explosivesAll)
				local invBox
				explosivesOnLevel = explosivesAll["offline"]["onLevelsInInventory"][levelNameExplosive]
				if explosivesOnLevel then
					for invBoxId, invBoxExplosives in pairs(explosivesOnLevel) do
						invBox = sim:object(invBoxId)
						if invBox and invBox.position:distance_to(explPos) <= radius then
							for sect, explIds in pairs(invBoxExplosives) do -- You can cut off the sections
								if explIds then
									for j = #explIds, 1, -1 do -- but here it is possible and with the objects in your inventory to do something, if they remember with explosives in front of this
										if explIds[j] then
											if explIds[j] ~= explId then
												explosive = sim:object(explIds[j])
												table.remove(explIds, j)
												if explosive then
													explodeOffline(explosive, true)
												end
											else
												table.remove(explIds, j)
											end
										end
									end
								end
							end
						end
					end
				end
				explosivesOnLevel = explosivesAll["offline"]["onLevels"][levelNameExplosive]
				if explosivesOnLevel then
					--amk.dump_table(explosivesAll)
					for sect, explIds in pairs(explosivesOnLevel) do -- You can cut off the sections
						if explIds then
							for j = #explIds, 1, -1 do
								if explIds[j] then 
									if explIds[j] ~= explId then
										explosive = sim:object(explIds[j])
										if explosive and explosive.position:distance_to(explPos) <= radius then
											table.remove(explIds, j)
											explodeOffline(explosive, true)
										end
									else
										table.remove(explIds, j)
									end
								end
							end
						end
					end
					--amk.dump_table(explosivesAll)
				end
			else
				sim:release(se_obj, true)
			end
			if first then
				news_manager.amk_send_tip(translate("sms_babah_another"), translate("sms_babah_expl"), 1, 10, "common_channel")
			end
		else
			if first then
				news_manager.amk_send_tip(translate("sms_babah_not_explode2"), translate("sms_babah"), 1, 10, "common_channel")
			end
		end
	end
end

-- for caching data
local explosivesInfo = {}

function collectExplosiveInfo(section)
	if not explosivesInfo[section] then
		local explosive = {
			["blast"] = 1.5,
			["blast_r"] = 2,
			["blast_impulse"] = 200,
			["blast_impulse_factor"] = 1,
			["frags"] = 0,
			["frags_r"] = 15,
			["frag_hit"] = 0.25,
			["frag_hit_impulse"] = 150,
			["hit_type_blast"] = "explosion",
			["hit_type_frag"] = "burn"
		}
		local varType
		for k, v in pairs(explosive) do
			varType = type(explosive[k])
			if varType == "number" then
				explosive[k] = getIniValueFloat(section, k, v, nil)
			elseif varType == "string" then
				explosive[k] = getIniValueString(section, k, v, nil)
			end
		end
		explosivesInfo[section] = explosive
	end
	return explosivesInfo[section]
end

-- collect information on victims
-- code of povzaimstvovan amk_offline_alife.offline_alife()
function collectExplosiveVictimsOffline(se_obj, radius)
		if TB3D_Modders.use_news_message == true then TB3D_Services.info_alert("babah: collectExplosiveVictimsOffline") end
	local sim = alife()
	local vdata = {}
	local ggraph = game_graph()
	local map = TB3D_Services.get_obj_level(se_obj.m_game_vertex_id)
	if map ~= "" then
		local off_npcs = amk_offline_alife.off_npcs
		local explPos = se_obj.position
		-- by stalker
		local function collectNPCs(offNPCs)
			if offNPCs then
				local offNPC
				local victim
				local sect
				local dist
				for a = 1, #offNPCs do
					offNPC = offNPCs[a]
					if offNPC then
						victim = sim:object(offNPC.id)
						if victim and victim.health and victim:health() > 0
								and victim.can_switch_online and victim:can_switch_online()
								and victim:name() == offNPC.name then
							sect = get_section(victim)
							dist = explPos:distance_to(victim.position)
							if dist <= radius then
								table.insert(vdata, {["id"] = victim.id, ["dist"] = dist, ["squere"] = getVictimSquare(sect)})
							end
						end
					end
				end
			end
		end
		collectNPCs(off_npcs[map].stalkers)
		collectNPCs(off_npcs[map].monsters)
	end
		if TB3D_Modders.use_news_message == true then TB3D_Services.info_alert("babah: collectExplosiveVictimsOffline done") end
	return vdata
end

-- for caching data
local victimsSquare = {}

function getVictimSquare(sect)
	if not victimsSquare[sect] then
		local victimSize = {0.5, 0.9, 0.5}
		local tmp = parse_nums(getIniValueString(sect, "ph_box0_size", table.concat(victimSize,", "), nil))
		if #tmp == 3 then
			victimSize = tmp
		end
		victimsSquare[sect] = (victimSize[1] + victimSize[3]) / 2 * victimSize[2]
	end
	return victimsSquare[sect]
end

function damageVictimsOffline(infoVictimsOffline, infoExplosive)
	local sim = alife()
	local se_obj
	local damage
	local health
	for i = 1, #infoVictimsOffline do
		se_obj = sim:object(infoVictimsOffline[i].id)
		if se_obj then
			damage = calcDamageForVictim(infoVictimsOffline[i], infoExplosive)
			if damage > 0 then
				health = se_obj:health() - damage
				if health < 0 then
					health = 0
				end
				amk_offline_alife.set_npc_health(se_obj, health)
			end
		end
	end
end

function calcDamageForVictim(victimInfo, infoExplosive)
	local rNorm = victimInfo["dist"] / infoExplosive["blast_r"]
	local damage = 0
	if victimInfo["dist"] < infoExplosive["blast_r"] then
		damage = infoExplosive["blast"] * (1 - rNorm * rNorm) * victimInfo["squere"]
		-- (1 - x ^ 2) http://yotx.ru/default.aspx?clr0=000000&exp0=1+-+x*x&mix=0&max=1&asx=on&u=mm&nx=X&aiy=on&asy=on&ny=Y&iw=600&ih=400&ict=png&aa=on
	end
	if infoExplosive["frags"] > 0 and victimInfo["dist"] < infoExplosive["frags_r"] then
		-- the probability that
		local sphereSquere = 4 * math.pi * victimInfo["dist"] * victimInfo["dist"]
		local prob = victimInfo["squere"] / sphereSquere
		for i = 1, infoExplosive["frags"] do
			if math_random() < prob then damage = damage + infoExplosive["frag_hit"] end
		end
	end
	-- His Majesty the Case
	damage = damage * (1 - math_random()*math_random()*math_random()*math_random())
	return damage
end
